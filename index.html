<!DOCTYPE html>
<html dir="ltr" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>quiz_viewer_general_en (no Math)</title>

    <link
      rel="icon"
      href="https://ensanbinadam.github.io/quiz_viewer_general_en/favicon.ico"
    />

    <style>
      * {
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      body {
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        min-height: 100vh;
        margin: 0;
        padding: 20px;
        color: #fff;
      }
      .container {
        max-width: 900px;
        margin: 20px auto;
        opacity: 0;
        transform: translateY(20px);
        animation: fadeIn 0.5s ease-out forwards;
      }
      .header {
        text-align: center;
        margin-bottom: 18px;
      }
      .quiz-box {
        background: rgba(255, 255, 255, 0.96);
        border-radius: 15px;
        padding: 24px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        color: #333;
        position: relative;
        overflow: auto;
      }
      .question {
        font-size: 1.4em;
        margin-bottom: 18px;
        font-weight: 700;
        line-height: 1.5;
        text-align: left;
      }
      .options {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      @media (min-width: 769px) {
        .options[data-layout="4x1"] {
          grid-template-columns: repeat(4, minmax(0, 1fr));
        }
      }

      .options-row {
        display: grid;
        gap: 10px;
      }
      .options-two {
        grid-template-columns: repeat(2, 1fr);
        max-width: 500px;
        margin: 0 auto;
      }
      .options-three {
        grid-template-columns: repeat(3, 1fr);
        max-width: 750px;
        margin: 0 auto;
      }
      .option {
        background: #f8f9fa;
        padding: 12px;
        border-radius: 10px;
        cursor: pointer;
        transition: 0.2s;
        border: 2px solid transparent;
        min-height: 110px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .option:hover {
        transform: translateX(8px);
        background: #eef1f4;
      }
      .option.correct {
        background: #28a745 !important;
        color: #fff !important;
      }
      .option.wrong {
        background: #dc3545 !important;
        color: #fff !important;
      }
      .option[aria-disabled="true"] {
        pointer-events: none;
        opacity: 0.9;
      }

      :root {
        --max-img-desktop: 60vh;
        --max-img-mobile: 45vh;
      }

      /* ÿµŸàÿ± ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸàÿßŸÑŸÜÿµ ÿßŸÑŸÇÿ±ÿßÿ¶Ÿä (ÿ≠ŸÇŸàŸÑ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖŸÜŸÅÿµŸÑÿ©) */
      .question-image,
      .reading-text-image {
        width: 100%;
        height: auto;
        object-fit: contain;
        max-height: var(--max-img-desktop);
        border-radius: 8px;
        margin: 8px 0;
        display: block;
      }

      /* ÿßŸÑÿµŸàÿ± ÿßŸÑŸÖÿØŸÖÿ¨ÿ© ÿØÿßÿÆŸÑ HTML ÿßŸÑŸÜÿµŸä */
      .reading-text-content img,
      .question-text img {
        max-width: 100%;
        height: auto;
        object-fit: contain;
        max-height: var(--max-img-desktop);
        display: block;
        margin: 8px auto;
      }

      @media (max-width: 768px) {
        .question-image,
        .reading-text-image,
        .reading-text-content img,
        .question-text img {
          max-height: var(--max-img-mobile);
        }
      }

      .option-image {
        background: transparent !important;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-top: 16px;
      }
      .nav-btn {
        background: #007bff;
        color: #fff;
        border: none;
        padding: 10px 22px;
        border-radius: 20px;
        cursor: pointer;
        transition: 0.2s;
      }
      .nav-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }
      .pause-btn {
        background: #ffc107;
        color: #000;
      }
      .progress-bar {
        height: 8px;
        background: #dee2e6;
        border-radius: 4px;
        margin: 16px 0;
        overflow: hidden;
      }
      .progress {
        height: 100%;
        background: #4caf50;
        width: 0;
        transition: width 0.3s ease;
      }
      .score-board {
        text-align: center;
        font-size: 1.5em;
        display: none;
      }
      .restart-btn {
        background: #007bff;
        color: #fff;
        border: none;
        padding: 12px 28px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 1.05em;
        margin: 18px auto;
        display: block;
        transition: transform 0.2s ease;
      }
      .reading-text {
        background: rgba(255, 255, 255, 0.9);
        color: #1e3c72;
        padding: 16px;
        border-radius: 12px;
        margin-bottom: 16px;
        font-size: 1.1em;
        line-height: 1.8;
        font-weight: 500;
        text-align: left;
      }
      .config-btn {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #fff;
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      @keyframes fadeIn {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .counters {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: -8px 0 16px 0;
        padding: 14px;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 10px;
        font-weight: 600;
        color: #2a5298;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
        font-size: 1.05em;
        gap: 10px;
      }
      #timer {
        flex: 1;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.9);
        padding: 8px 18px;
        border-radius: 24px;
        font-weight: 800;
      }
      #questionCounter::before {
        content: "üìå ";
        margin-right: 6px;
      }
      #scoreCounter::before {
        content: "üèÜ ";
        margin-right: 6px;
      }
      #timer::before {
        content: "‚è≥";
        font-size: 1.2em;
        animation: pulse 2s infinite;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.08);
        }
        100% {
          transform: scale(1);
        }
      }

      .question-content {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 12px;
      }
      .option-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        width: 100%;
      }
      .option-text {
        text-align: center;
        padding: 4px;
        width: 100%;
        font-size: 18px;
        font-weight: 700;
        color: #333;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }

      .buttons-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        margin: 14px 0;
      }
      .action-btn {
        background: #007bff;
        color: #fff;
        border: none;
        padding: 10px 18px;
        border-radius: 20px;
        cursor: pointer;
        transition: 0.2s;
        font-size: 0.95em;
      }
      .action-btn.settings-btn {
        background: #6c757d;
      }
      .action-btn.sample {
        background: #28a745;
      }

      .settings-panel {
        background: #fff;
        padding: 16px;
        border-radius: 10px;
        margin-bottom: 16px;
        color: #333;
        border: 1px solid #ccc;
        margin-top: 10px;
        max-width: 640px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
        display: none;
      }
      .settings-title {
        font-weight: 800;
        margin-bottom: 10px;
        font-size: 18px;
      }
      .settings-option {
        margin-bottom: 10px;
      }
      .settings-option label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
      }
      .settings-option select,
      .settings-option input {
        width: 100%;
        padding: 8px;
        border-radius: 6px;
        border: 1px solid #ddd;
      }

      .config-panel {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #fff;
        padding: 22px;
        border-radius: 14px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        display: none;
        color: #333;
        z-index: 9999;
        width: 92%;
        max-width: 520px;
      }
      .form-control {
        width: 100%;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #ccc;
        resize: vertical;
      }
      .form-group {
        margin-top: 12px;
      }

      footer {
        position: relative;
        width: 100%;
        text-align: center;
        padding: 10px;
        background: #f1f1f1;
        color: #333;
        direction: ltr;
        border-radius: 10px;
        margin-top: 16px;
      }

      .reading-text a,
      .question a,
      .option-text a {
        text-decoration: underline;
      }

      @media (max-width: 768px) {
        .options {
          grid-template-columns: 1fr;
        }
        .option {
          min-height: 100px;
        }
        .question {
          font-size: 1.2em;
        }
      }
      /* Keyboard focus visibility for better accessibility */
      .option:focus,
      .option:focus-visible {
        outline: 3px solid #007bff;
        outline-offset: 2px;
      }
      .nav-btn:focus,
      .action-btn:focus {
        outline: 3px solid #2a5298;
        outline-offset: 2px;
      }
    </style>
  </head>
  <body>
    <button
      class="config-btn"
      onclick="toggleConfigPanel()"
      aria-label="Control panel"
    >
      ‚öôÔ∏è
    </button>

    <div class="container">
      <div class="header">
        <h1 id="quizTitle">General Quiz - Lite</h1>
        <p id="instructions">
          Select the correct answer for each question before time runs out.
        </p>
      </div>

      <div class="buttons-container" id="teacherButtons">
        <button class="action-btn" id="loadButton">Load Questions</button>
        <button
          class="action-btn settings-btn"
          id="settingsBtn"
          onclick="toggleSettingsPanel()"
        >
          Display Settings
        </button>
        <button class="action-btn" id="editButton" onclick="toggleEditMode()">
          Edit Question
        </button>
        <button class="action-btn" id="saveQuestionsButton">
          Save Questions
        </button>
        <button class="action-btn" id="saveAppButton">Student Version</button>
        <button
          class="action-btn"
          id="resetProgressBtn"
          onclick="resetProgress()"
        >
          Reset Progress
        </button>
      </div>

      <div class="settings-panel" id="editPanel" style="display: none">
        <div class="settings-title">Edit Question</div>
        <div class="settings-option">
          <label for="editReadingText">Reading text:</label>
          <textarea
            id="editReadingText"
            class="form-control"
            rows="4"
          ></textarea>
          <label for="editReadingImage">Reading image:</label>
          <input type="file" id="editReadingImage" accept="image/*" />
          <img
            id="readingImagePreview"
            style="
              display: none;
              max-width: 100%;
              max-height: 160px;
              margin: 8px 0;
            "
          />
        </div>
        <div class="settings-option">
          <label for="editQuestionText">Question:</label>
          <input type="text" id="editQuestionText" class="form-control" />
          <label for="editQuestionImage">Question image:</label>
          <input type="file" id="editQuestionImage" accept="image/*" />
          <img
            id="questionImagePreview"
            style="
              display: none;
              max-width: 100%;
              max-height: 160px;
              margin: 8px 0;
            "
          />
        </div>
        <div class="settings-option">
          <label>Options:</label>
          <div style="display: grid; gap: 10px">
            <div>
              <input type="checkbox" id="correct1" />
              <label for="editOption1">Option 1:</label>
              <input type="text" id="editOption1" class="form-control" />
              <input type="file" id="editOptionImage1" accept="image/*" />
              <img
                id="optionImagePreview1"
                style="
                  display: none;
                  max-width: 100%;
                  max-height: 110px;
                  margin: 8px 0;
                "
              />
            </div>
            <div>
              <input type="checkbox" id="correct2" />
              <label for="editOption2">Option 2:</label>
              <input type="text" id="editOption2" class="form-control" />
              <input type="file" id="editOptionImage2" accept="image/*" />
              <img
                id="optionImagePreview2"
                style="
                  display: none;
                  max-width: 100%;
                  max-height: 110px;
                  margin: 8px 0;
                "
              />
            </div>
            <div>
              <input type="checkbox" id="correct3" />
              <label for="editOption3">Option 3:</label>
              <input type="text" id="editOption3" class="form-control" />
              <input type="file" id="editOptionImage3" accept="image/*" />
              <img
                id="optionImagePreview3"
                style="
                  display: none;
                  max-width: 100%;
                  max-height: 110px;
                  margin: 8px 0;
                "
              />
            </div>
            <div>
              <input type="checkbox" id="correct4" />
              <label for="editOption4">Option 4:</label>
              <input type="text" id="editOption4" class="form-control" />
              <input type="file" id="editOptionImage4" accept="image/*" />
              <img
                id="optionImagePreview4"
                style="
                  display: none;
                  max-width: 100%;
                  max-height: 110px;
                  margin: 8px 0;
                "
              />
            </div>
          </div>
        </div>
        <div
          class="settings-footer"
          style="
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
          "
        >
          <button
            class="nav-btn"
            onclick="saveEdit()"
            style="background: #28a745"
          >
            Save
          </button>
          <button
            class="nav-btn"
            onclick="addNewQuestion()"
            style="background: #007bff"
          >
            Add Question
          </button>
          <button
            class="nav-btn"
            onclick="deleteCurrentQuestion()"
            style="background: #dc3545"
          >
            Delete
          </button>
          <button class="nav-btn" onclick="cancelEdit()">Cancel</button>
        </div>
      </div>

      <div class="settings-panel" id="settingsPanel">
        <div class="settings-title">Display Settings</div>
        <div class="settings-option">
          <label for="numeralType">Digits:</label>
          <select id="numeralType" onchange="changeNumeralType()">
            <option value="arabic" selected="">Latin (1, 2, 3)</option>
            <option value="eastern">Eastern Arabic (Ÿ°, Ÿ¢, Ÿ£)</option>
          </select>
        </div>
        <div class="settings-option">
          <button
            onclick="cleanEasternNumerals()"
            style="
              margin-top: 8px;
              background-color: #dc3545;
              color: white;
              padding: 6px 10px;
              border: none;
              border-radius: 6px;
              cursor: pointer;
            "
          >
            üßπ Clean Eastern digits inside questions
          </button>
        </div>
        <div class="settings-option">
          <label for="questionTime">Time per question (seconds):</label>
          <input
            id="questionTime"
            type="number"
            min="5"
            max="180"
            value="30"
            onchange="changeQuestionTime()"
          />
        </div>

        <div class="settings-option">
          <label for="optionsLayout">ÿ™ÿÆÿ∑Ÿäÿ∑ ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™:</label>
          <select id="optionsLayout" onchange="changeOptionsLayout()">
            <option value="2x2" selected="">ÿ¥ÿ®ŸÉÿ© 2√ó2 (ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä)</option>
            <option value="4x1">ÿ≥ÿ∑ÿ± Ÿàÿßÿ≠ÿØ 4√ó1</option>
          </select>
        </div>

        <div class="settings-footer">
          <button class="nav-btn" onclick="toggleSettingsPanel()">
            Save &amp; Close
          </button>
        </div>
      </div>

      <div class="counters" id="countersBox">
        <div id="questionCounter" aria-live="polite">üìå Question 0 of 0</div>
        <div id="timer" aria-live="polite">‚è≥ Time left: 0 seconds</div>
        <div id="scoreCounter" aria-live="polite">üèÜ Score: 0 of 0</div>
      </div>

      <div class="reading-text" id="readingText" style="display: none"></div>

      <div class="quiz-box">
        <div class="question" id="question"></div>
        <div class="options" id="options"></div>
        <div class="controls">
          <button
            class="nav-btn"
            id="prevBtn"
            onclick="previousQuestion()"
            disabled=""
          >
            Previous
          </button>
          <button
            class="nav-btn pause-btn"
            id="pauseBtn"
            onclick="togglePause()"
          >
            Pause
          </button>
          <button
            class="nav-btn"
            id="nextBtn"
            onclick="nextQuestion()"
            disabled=""
          >
            Next
          </button>
        </div>
        <div class="progress-bar">
          <div class="progress" id="progress"></div>
        </div>
      </div>
    </div>

    <div class="score-board" id="scoreBoard">
      <h2>
        Your final score: <span id="finalScore">0</span>/<span
          id="totalQuestions"
          >0</span
        >
      </h2>
      <button class="restart-btn" onclick="restartQuiz()">Retry</button>
    </div>

    <div class="config-panel" id="configPanel">
      <h3>Control Panel</h3>
      <label for="titleInput">Quiz title:</label>
      <input class="form-control" id="titleInput" type="text" />
      <label for="instructionsInput" class="form-group">Instructions:</label>
      <textarea class="form-control" id="instructionsInput" rows="4"></textarea>
      <div class="form-group">
        <label for="footerInput">Footer:</label>
        <textarea class="form-control" id="footerInput" rows="3">
Prepared &amp; designed by ‚Ä¢ English Department</textarea
        >
      </div>
      <div class="form-group" style="display: flex; gap: 8px; flex-wrap: wrap">
        <button class="nav-btn" onclick="saveConfig()">Save changes</button>
        <button class="nav-btn" onclick="toggleConfigPanel()">Cancel</button>
      </div>
    </div>

    <footer id="quizFooter">
      Prepared &amp; designed by ‚Ä¢ English Department
    </footer>

    <script>
      /* --- cdn.jsdelivr.net-npm-dompurify_3.1.6-dist-purify.min.52acb203.js --- */
      /*! @license DOMPurify 3.1.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.6/LICENSE */
      !(function (e, t) {
        "object" == typeof exports && "undefined" != typeof module
          ? (module.exports = t())
          : "function" == typeof define && define.amd
          ? define(t)
          : ((e =
              "undefined" != typeof globalThis
                ? globalThis
                : e || self).DOMPurify = t());
      })(this, function () {
        "use strict";
        const {
          entries: e,
          setPrototypeOf: t,
          isFrozen: n,
          getPrototypeOf: o,
          getOwnPropertyDescriptor: r,
        } = Object;
        let { freeze: i, seal: a, create: l } = Object,
          { apply: c, construct: s } = "undefined" != typeof Reflect && Reflect;
        i ||
          (i = function (e) {
            return e;
          }),
          a ||
            (a = function (e) {
              return e;
            }),
          c ||
            (c = function (e, t, n) {
              return e.apply(t, n);
            }),
          s ||
            (s = function (e, t) {
              return new e(...t);
            });
        const u = b(Array.prototype.forEach),
          m = b(Array.prototype.pop),
          p = b(Array.prototype.push),
          f = b(String.prototype.toLowerCase),
          d = b(String.prototype.toString),
          h = b(String.prototype.match),
          g = b(String.prototype.replace),
          T = b(String.prototype.indexOf),
          y = b(String.prototype.trim),
          E = b(Object.prototype.hasOwnProperty),
          _ = b(RegExp.prototype.test),
          A =
            ((N = TypeError),
            function () {
              for (
                var e = arguments.length, t = new Array(e), n = 0;
                n < e;
                n++
              )
                t[n] = arguments[n];
              return s(N, t);
            });
        var N;
        function b(e) {
          return function (t) {
            for (
              var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), r = 1;
              r < n;
              r++
            )
              o[r - 1] = arguments[r];
            return c(e, t, o);
          };
        }
        function S(e, o) {
          let r =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : f;
          t && t(e, null);
          let i = o.length;
          for (; i--; ) {
            let t = o[i];
            if ("string" == typeof t) {
              const e = r(t);
              e !== t && (n(o) || (o[i] = e), (t = e));
            }
            e[t] = !0;
          }
          return e;
        }
        function R(e) {
          for (let t = 0; t < e.length; t++) {
            E(e, t) || (e[t] = null);
          }
          return e;
        }
        function w(t) {
          const n = l(null);
          for (const [o, r] of e(t)) {
            E(t, o) &&
              (Array.isArray(r)
                ? (n[o] = R(r))
                : r && "object" == typeof r && r.constructor === Object
                ? (n[o] = w(r))
                : (n[o] = r));
          }
          return n;
        }
        function C(e, t) {
          for (; null !== e; ) {
            const n = r(e, t);
            if (n) {
              if (n.get) return b(n.get);
              if ("function" == typeof n.value) return b(n.value);
            }
            e = o(e);
          }
          return function () {
            return null;
          };
        }
        const L = i([
            "a",
            "abbr",
            "acronym",
            "address",
            "area",
            "article",
            "aside",
            "audio",
            "b",
            "bdi",
            "bdo",
            "big",
            "blink",
            "blockquote",
            "body",
            "br",
            "button",
            "canvas",
            "caption",
            "center",
            "cite",
            "code",
            "col",
            "colgroup",
            "content",
            "data",
            "datalist",
            "dd",
            "decorator",
            "del",
            "details",
            "dfn",
            "dialog",
            "dir",
            "div",
            "dl",
            "dt",
            "element",
            "em",
            "fieldset",
            "figcaption",
            "figure",
            "font",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "head",
            "header",
            "hgroup",
            "hr",
            "html",
            "i",
            "img",
            "input",
            "ins",
            "kbd",
            "label",
            "legend",
            "li",
            "main",
            "map",
            "mark",
            "marquee",
            "menu",
            "menuitem",
            "meter",
            "nav",
            "nobr",
            "ol",
            "optgroup",
            "option",
            "output",
            "p",
            "picture",
            "pre",
            "progress",
            "q",
            "rp",
            "rt",
            "ruby",
            "s",
            "samp",
            "section",
            "select",
            "shadow",
            "small",
            "source",
            "spacer",
            "span",
            "strike",
            "strong",
            "style",
            "sub",
            "summary",
            "sup",
            "table",
            "tbody",
            "td",
            "template",
            "textarea",
            "tfoot",
            "th",
            "thead",
            "time",
            "tr",
            "track",
            "tt",
            "u",
            "ul",
            "var",
            "video",
            "wbr",
          ]),
          D = i([
            "svg",
            "a",
            "altglyph",
            "altglyphdef",
            "altglyphitem",
            "animatecolor",
            "animatemotion",
            "animatetransform",
            "circle",
            "clippath",
            "defs",
            "desc",
            "ellipse",
            "filter",
            "font",
            "g",
            "glyph",
            "glyphref",
            "hkern",
            "image",
            "line",
            "lineargradient",
            "marker",
            "mask",
            "metadata",
            "mpath",
            "path",
            "pattern",
            "polygon",
            "polyline",
            "radialgradient",
            "rect",
            "stop",
            "style",
            "switch",
            "symbol",
            "text",
            "textpath",
            "title",
            "tref",
            "tspan",
            "view",
            "vkern",
          ]),
          v = i([
            "feBlend",
            "feColorMatrix",
            "feComponentTransfer",
            "feComposite",
            "feConvolveMatrix",
            "feDiffuseLighting",
            "feDisplacementMap",
            "feDistantLight",
            "feDropShadow",
            "feFlood",
            "feFuncA",
            "feFuncB",
            "feFuncG",
            "feFuncR",
            "feGaussianBlur",
            "feImage",
            "feMerge",
            "feMergeNode",
            "feMorphology",
            "feOffset",
            "fePointLight",
            "feSpecularLighting",
            "feSpotLight",
            "feTile",
            "feTurbulence",
          ]),
          O = i([
            "animate",
            "color-profile",
            "cursor",
            "discard",
            "font-face",
            "font-face-format",
            "font-face-name",
            "font-face-src",
            "font-face-uri",
            "foreignobject",
            "hatch",
            "hatchpath",
            "mesh",
            "meshgradient",
            "meshpatch",
            "meshrow",
            "missing-glyph",
            "script",
            "set",
            "solidcolor",
            "unknown",
            "use",
          ]),
          x = i([
            "math",
            "menclose",
            "merror",
            "mfenced",
            "mfrac",
            "mglyph",
            "mi",
            "mlabeledtr",
            "mmultiscripts",
            "mn",
            "mo",
            "mover",
            "mpadded",
            "mphantom",
            "mroot",
            "mrow",
            "ms",
            "mspace",
            "msqrt",
            "mstyle",
            "msub",
            "msup",
            "msubsup",
            "mtable",
            "mtd",
            "mtext",
            "mtr",
            "munder",
            "munderover",
            "mprescripts",
          ]),
          k = i([
            "maction",
            "maligngroup",
            "malignmark",
            "mlongdiv",
            "mscarries",
            "mscarry",
            "msgroup",
            "mstack",
            "msline",
            "msrow",
            "semantics",
            "annotation",
            "annotation-xml",
            "mprescripts",
            "none",
          ]),
          M = i(["#text"]),
          I = i([
            "accept",
            "action",
            "align",
            "alt",
            "autocapitalize",
            "autocomplete",
            "autopictureinpicture",
            "autoplay",
            "background",
            "bgcolor",
            "border",
            "capture",
            "cellpadding",
            "cellspacing",
            "checked",
            "cite",
            "class",
            "clear",
            "color",
            "cols",
            "colspan",
            "controls",
            "controlslist",
            "coords",
            "crossorigin",
            "datetime",
            "decoding",
            "default",
            "dir",
            "disabled",
            "disablepictureinpicture",
            "disableremoteplayback",
            "download",
            "draggable",
            "enctype",
            "enterkeyhint",
            "face",
            "for",
            "headers",
            "height",
            "hidden",
            "high",
            "href",
            "hreflang",
            "id",
            "inputmode",
            "integrity",
            "ismap",
            "kind",
            "label",
            "lang",
            "list",
            "loading",
            "loop",
            "low",
            "max",
            "maxlength",
            "media",
            "method",
            "min",
            "minlength",
            "multiple",
            "muted",
            "name",
            "nonce",
            "noshade",
            "novalidate",
            "nowrap",
            "open",
            "optimum",
            "pattern",
            "placeholder",
            "playsinline",
            "popover",
            "popovertarget",
            "popovertargetaction",
            "poster",
            "preload",
            "pubdate",
            "radiogroup",
            "readonly",
            "rel",
            "required",
            "rev",
            "reversed",
            "role",
            "rows",
            "rowspan",
            "spellcheck",
            "scope",
            "selected",
            "shape",
            "size",
            "sizes",
            "span",
            "srclang",
            "start",
            "src",
            "srcset",
            "step",
            "style",
            "summary",
            "tabindex",
            "title",
            "translate",
            "type",
            "usemap",
            "valign",
            "value",
            "width",
            "wrap",
            "xmlns",
            "slot",
          ]),
          U = i([
            "accent-height",
            "accumulate",
            "additive",
            "alignment-baseline",
            "ascent",
            "attributename",
            "attributetype",
            "azimuth",
            "basefrequency",
            "baseline-shift",
            "begin",
            "bias",
            "by",
            "class",
            "clip",
            "clippathunits",
            "clip-path",
            "clip-rule",
            "color",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "cx",
            "cy",
            "d",
            "dx",
            "dy",
            "diffuseconstant",
            "direction",
            "display",
            "divisor",
            "dur",
            "edgemode",
            "elevation",
            "end",
            "fill",
            "fill-opacity",
            "fill-rule",
            "filter",
            "filterunits",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "fx",
            "fy",
            "g1",
            "g2",
            "glyph-name",
            "glyphref",
            "gradientunits",
            "gradienttransform",
            "height",
            "href",
            "id",
            "image-rendering",
            "in",
            "in2",
            "k",
            "k1",
            "k2",
            "k3",
            "k4",
            "kerning",
            "keypoints",
            "keysplines",
            "keytimes",
            "lang",
            "lengthadjust",
            "letter-spacing",
            "kernelmatrix",
            "kernelunitlength",
            "lighting-color",
            "local",
            "marker-end",
            "marker-mid",
            "marker-start",
            "markerheight",
            "markerunits",
            "markerwidth",
            "maskcontentunits",
            "maskunits",
            "max",
            "mask",
            "media",
            "method",
            "mode",
            "min",
            "name",
            "numoctaves",
            "offset",
            "operator",
            "opacity",
            "order",
            "orient",
            "orientation",
            "origin",
            "overflow",
            "paint-order",
            "path",
            "pathlength",
            "patterncontentunits",
            "patterntransform",
            "patternunits",
            "points",
            "preservealpha",
            "preserveaspectratio",
            "primitiveunits",
            "r",
            "rx",
            "ry",
            "radius",
            "refx",
            "refy",
            "repeatcount",
            "repeatdur",
            "restart",
            "result",
            "rotate",
            "scale",
            "seed",
            "shape-rendering",
            "specularconstant",
            "specularexponent",
            "spreadmethod",
            "startoffset",
            "stddeviation",
            "stitchtiles",
            "stop-color",
            "stop-opacity",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke",
            "stroke-width",
            "style",
            "surfacescale",
            "systemlanguage",
            "tabindex",
            "targetx",
            "targety",
            "transform",
            "transform-origin",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "textlength",
            "type",
            "u1",
            "u2",
            "unicode",
            "values",
            "viewbox",
            "visibility",
            "version",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "width",
            "word-spacing",
            "wrap",
            "writing-mode",
            "xchannelselector",
            "ychannelselector",
            "x",
            "x1",
            "x2",
            "xmlns",
            "y",
            "y1",
            "y2",
            "z",
            "zoomandpan",
          ]),
          P = i([
            "accent",
            "accentunder",
            "align",
            "bevelled",
            "close",
            "columnsalign",
            "columnlines",
            "columnspan",
            "denomalign",
            "depth",
            "dir",
            "display",
            "displaystyle",
            "encoding",
            "fence",
            "frame",
            "height",
            "href",
            "id",
            "largeop",
            "length",
            "linethickness",
            "lspace",
            "lquote",
            "mathbackground",
            "mathcolor",
            "mathsize",
            "mathvariant",
            "maxsize",
            "minsize",
            "movablelimits",
            "notation",
            "numalign",
            "open",
            "rowalign",
            "rowlines",
            "rowspacing",
            "rowspan",
            "rspace",
            "rquote",
            "scriptlevel",
            "scriptminsize",
            "scriptsizemultiplier",
            "selection",
            "separator",
            "separators",
            "stretchy",
            "subscriptshift",
            "supscriptshift",
            "symmetric",
            "voffset",
            "width",
            "xmlns",
          ]),
          F = i([
            "xlink:href",
            "xml:id",
            "xlink:title",
            "xml:space",
            "xmlns:xlink",
          ]),
          H = a(/\{\{[\w\W]*|[\w\W]*\}\}/gm),
          z = a(/<%[\w\W]*|[\w\W]*%>/gm),
          B = a(/\${[\w\W]*}/gm),
          W = a(/^data-[\-\w.\u00B7-\uFFFF]/),
          G = a(/^aria-[\-\w]+$/),
          Y = a(
            /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
          ),
          j = a(/^(?:\w+script|data):/i),
          X = a(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),
          q = a(/^html$/i),
          $ = a(/^[a-z][.\w]*(-[.\w]+)+$/i);
        var K = Object.freeze({
          __proto__: null,
          MUSTACHE_EXPR: H,
          ERB_EXPR: z,
          TMPLIT_EXPR: B,
          DATA_ATTR: W,
          ARIA_ATTR: G,
          IS_ALLOWED_URI: Y,
          IS_SCRIPT_OR_DATA: j,
          ATTR_WHITESPACE: X,
          DOCTYPE_NAME: q,
          CUSTOM_ELEMENT: $,
        });
        const V = 1,
          Z = 3,
          J = 7,
          Q = 8,
          ee = 9,
          te = function () {
            return "undefined" == typeof window ? null : window;
          };
        var ne = (function t() {
          let n =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : te();
          const o = (e) => t(e);
          if (
            ((o.version = "3.1.6"),
            (o.removed = []),
            !n || !n.document || n.document.nodeType !== ee)
          )
            return (o.isSupported = !1), o;
          let { document: r } = n;
          const a = r,
            c = a.currentScript,
            {
              DocumentFragment: s,
              HTMLTemplateElement: N,
              Node: b,
              Element: R,
              NodeFilter: H,
              NamedNodeMap: z = n.NamedNodeMap || n.MozNamedAttrMap,
              HTMLFormElement: B,
              DOMParser: W,
              trustedTypes: G,
            } = n,
            j = R.prototype,
            X = C(j, "cloneNode"),
            $ = C(j, "remove"),
            ne = C(j, "nextSibling"),
            oe = C(j, "childNodes"),
            re = C(j, "parentNode");
          if ("function" == typeof N) {
            const e = r.createElement("template");
            e.content &&
              e.content.ownerDocument &&
              (r = e.content.ownerDocument);
          }
          let ie,
            ae = "";
          const {
              implementation: le,
              createNodeIterator: ce,
              createDocumentFragment: se,
              getElementsByTagName: ue,
            } = r,
            { importNode: me } = a;
          let pe = {};
          o.isSupported =
            "function" == typeof e &&
            "function" == typeof re &&
            le &&
            void 0 !== le.createHTMLDocument;
          const {
            MUSTACHE_EXPR: fe,
            ERB_EXPR: de,
            TMPLIT_EXPR: he,
            DATA_ATTR: ge,
            ARIA_ATTR: Te,
            IS_SCRIPT_OR_DATA: ye,
            ATTR_WHITESPACE: Ee,
            CUSTOM_ELEMENT: _e,
          } = K;
          let { IS_ALLOWED_URI: Ae } = K,
            Ne = null;
          const be = S({}, [...L, ...D, ...v, ...x, ...M]);
          let Se = null;
          const Re = S({}, [...I, ...U, ...P, ...F]);
          let we = Object.seal(
              l(null, {
                tagNameCheck: {
                  writable: !0,
                  configurable: !1,
                  enumerable: !0,
                  value: null,
                },
                attributeNameCheck: {
                  writable: !0,
                  configurable: !1,
                  enumerable: !0,
                  value: null,
                },
                allowCustomizedBuiltInElements: {
                  writable: !0,
                  configurable: !1,
                  enumerable: !0,
                  value: !1,
                },
              })
            ),
            Ce = null,
            Le = null,
            De = !0,
            ve = !0,
            Oe = !1,
            xe = !0,
            ke = !1,
            Me = !0,
            Ie = !1,
            Ue = !1,
            Pe = !1,
            Fe = !1,
            He = !1,
            ze = !1,
            Be = !0,
            We = !1,
            Ge = !0,
            Ye = !1,
            je = {},
            Xe = null;
          const qe = S({}, [
            "annotation-xml",
            "audio",
            "colgroup",
            "desc",
            "foreignobject",
            "head",
            "iframe",
            "math",
            "mi",
            "mn",
            "mo",
            "ms",
            "mtext",
            "noembed",
            "noframes",
            "noscript",
            "plaintext",
            "script",
            "style",
            "svg",
            "template",
            "thead",
            "title",
            "video",
            "xmp",
          ]);
          let $e = null;
          const Ke = S({}, [
            "audio",
            "video",
            "img",
            "source",
            "image",
            "track",
          ]);
          let Ve = null;
          const Ze = S({}, [
              "alt",
              "class",
              "for",
              "id",
              "label",
              "name",
              "pattern",
              "placeholder",
              "role",
              "summary",
              "title",
              "value",
              "style",
              "xmlns",
            ]),
            Je = "http://www.w3.org/1998/Math/MathML",
            Qe = "http://www.w3.org/2000/svg",
            et = "http://www.w3.org/1999/xhtml";
          let tt = et,
            nt = !1,
            ot = null;
          const rt = S({}, [Je, Qe, et], d);
          let it = null;
          const at = ["application/xhtml+xml", "text/html"];
          let lt = null,
            ct = null;
          const st = r.createElement("form"),
            ut = function (e) {
              return e instanceof RegExp || e instanceof Function;
            },
            mt = function () {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : {};
              if (!ct || ct !== e) {
                if (
                  ((e && "object" == typeof e) || (e = {}),
                  (e = w(e)),
                  (it =
                    -1 === at.indexOf(e.PARSER_MEDIA_TYPE)
                      ? "text/html"
                      : e.PARSER_MEDIA_TYPE),
                  (lt = "application/xhtml+xml" === it ? d : f),
                  (Ne = E(e, "ALLOWED_TAGS") ? S({}, e.ALLOWED_TAGS, lt) : be),
                  (Se = E(e, "ALLOWED_ATTR") ? S({}, e.ALLOWED_ATTR, lt) : Re),
                  (ot = E(e, "ALLOWED_NAMESPACES")
                    ? S({}, e.ALLOWED_NAMESPACES, d)
                    : rt),
                  (Ve = E(e, "ADD_URI_SAFE_ATTR")
                    ? S(w(Ze), e.ADD_URI_SAFE_ATTR, lt)
                    : Ze),
                  ($e = E(e, "ADD_DATA_URI_TAGS")
                    ? S(w(Ke), e.ADD_DATA_URI_TAGS, lt)
                    : Ke),
                  (Xe = E(e, "FORBID_CONTENTS")
                    ? S({}, e.FORBID_CONTENTS, lt)
                    : qe),
                  (Ce = E(e, "FORBID_TAGS") ? S({}, e.FORBID_TAGS, lt) : {}),
                  (Le = E(e, "FORBID_ATTR") ? S({}, e.FORBID_ATTR, lt) : {}),
                  (je = !!E(e, "USE_PROFILES") && e.USE_PROFILES),
                  (De = !1 !== e.ALLOW_ARIA_ATTR),
                  (ve = !1 !== e.ALLOW_DATA_ATTR),
                  (Oe = e.ALLOW_UNKNOWN_PROTOCOLS || !1),
                  (xe = !1 !== e.ALLOW_SELF_CLOSE_IN_ATTR),
                  (ke = e.SAFE_FOR_TEMPLATES || !1),
                  (Me = !1 !== e.SAFE_FOR_XML),
                  (Ie = e.WHOLE_DOCUMENT || !1),
                  (Fe = e.RETURN_DOM || !1),
                  (He = e.RETURN_DOM_FRAGMENT || !1),
                  (ze = e.RETURN_TRUSTED_TYPE || !1),
                  (Pe = e.FORCE_BODY || !1),
                  (Be = !1 !== e.SANITIZE_DOM),
                  (We = e.SANITIZE_NAMED_PROPS || !1),
                  (Ge = !1 !== e.KEEP_CONTENT),
                  (Ye = e.IN_PLACE || !1),
                  (Ae = e.ALLOWED_URI_REGEXP || Y),
                  (tt = e.NAMESPACE || et),
                  (we = e.CUSTOM_ELEMENT_HANDLING || {}),
                  e.CUSTOM_ELEMENT_HANDLING &&
                    ut(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) &&
                    (we.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck),
                  e.CUSTOM_ELEMENT_HANDLING &&
                    ut(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) &&
                    (we.attributeNameCheck =
                      e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),
                  e.CUSTOM_ELEMENT_HANDLING &&
                    "boolean" ==
                      typeof e.CUSTOM_ELEMENT_HANDLING
                        .allowCustomizedBuiltInElements &&
                    (we.allowCustomizedBuiltInElements =
                      e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),
                  ke && (ve = !1),
                  He && (Fe = !0),
                  je &&
                    ((Ne = S({}, M)),
                    (Se = []),
                    !0 === je.html && (S(Ne, L), S(Se, I)),
                    !0 === je.svg && (S(Ne, D), S(Se, U), S(Se, F)),
                    !0 === je.svgFilters && (S(Ne, v), S(Se, U), S(Se, F)),
                    !0 === je.mathMl && (S(Ne, x), S(Se, P), S(Se, F))),
                  e.ADD_TAGS &&
                    (Ne === be && (Ne = w(Ne)), S(Ne, e.ADD_TAGS, lt)),
                  e.ADD_ATTR &&
                    (Se === Re && (Se = w(Se)), S(Se, e.ADD_ATTR, lt)),
                  e.ADD_URI_SAFE_ATTR && S(Ve, e.ADD_URI_SAFE_ATTR, lt),
                  e.FORBID_CONTENTS &&
                    (Xe === qe && (Xe = w(Xe)), S(Xe, e.FORBID_CONTENTS, lt)),
                  Ge && (Ne["#text"] = !0),
                  Ie && S(Ne, ["html", "head", "body"]),
                  Ne.table && (S(Ne, ["tbody"]), delete Ce.tbody),
                  e.TRUSTED_TYPES_POLICY)
                ) {
                  if ("function" != typeof e.TRUSTED_TYPES_POLICY.createHTML)
                    throw A(
                      'TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.'
                    );
                  if (
                    "function" != typeof e.TRUSTED_TYPES_POLICY.createScriptURL
                  )
                    throw A(
                      'TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.'
                    );
                  (ie = e.TRUSTED_TYPES_POLICY), (ae = ie.createHTML(""));
                } else
                  void 0 === ie &&
                    (ie = (function (e, t) {
                      if (
                        "object" != typeof e ||
                        "function" != typeof e.createPolicy
                      )
                        return null;
                      let n = null;
                      const o = "data-tt-policy-suffix";
                      t && t.hasAttribute(o) && (n = t.getAttribute(o));
                      const r = "dompurify" + (n ? "#" + n : "");
                      try {
                        return e.createPolicy(r, {
                          createHTML: (e) => e,
                          createScriptURL: (e) => e,
                        });
                      } catch (e) {
                        return (
                          console.warn(
                            "TrustedTypes policy " +
                              r +
                              " could not be created."
                          ),
                          null
                        );
                      }
                    })(G, c)),
                    null !== ie &&
                      "string" == typeof ae &&
                      (ae = ie.createHTML(""));
                i && i(e), (ct = e);
              }
            },
            pt = S({}, ["mi", "mo", "mn", "ms", "mtext"]),
            ft = S({}, ["foreignobject", "annotation-xml"]),
            dt = S({}, ["title", "style", "font", "a", "script"]),
            ht = S({}, [...D, ...v, ...O]),
            gt = S({}, [...x, ...k]),
            Tt = function (e) {
              p(o.removed, { element: e });
              try {
                re(e).removeChild(e);
              } catch (t) {
                $(e);
              }
            },
            yt = function (e, t) {
              try {
                p(o.removed, { attribute: t.getAttributeNode(e), from: t });
              } catch (e) {
                p(o.removed, { attribute: null, from: t });
              }
              if ((t.removeAttribute(e), "is" === e && !Se[e]))
                if (Fe || He)
                  try {
                    Tt(t);
                  } catch (e) {}
                else
                  try {
                    t.setAttribute(e, "");
                  } catch (e) {}
            },
            Et = function (e) {
              let t = null,
                n = null;
              if (Pe) e = "<remove></remove>" + e;
              else {
                const t = h(e, /^[\r\n\t ]+/);
                n = t && t[0];
              }
              "application/xhtml+xml" === it &&
                tt === et &&
                (e =
                  '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' +
                  e +
                  "</body></html>");
              const o = ie ? ie.createHTML(e) : e;
              if (tt === et)
                try {
                  t = new W().parseFromString(o, it);
                } catch (e) {}
              if (!t || !t.documentElement) {
                t = le.createDocument(tt, "template", null);
                try {
                  t.documentElement.innerHTML = nt ? ae : o;
                } catch (e) {}
              }
              const i = t.body || t.documentElement;
              return (
                e &&
                  n &&
                  i.insertBefore(r.createTextNode(n), i.childNodes[0] || null),
                tt === et
                  ? ue.call(t, Ie ? "html" : "body")[0]
                  : Ie
                  ? t.documentElement
                  : i
              );
            },
            _t = function (e) {
              return ce.call(
                e.ownerDocument || e,
                e,
                H.SHOW_ELEMENT |
                  H.SHOW_COMMENT |
                  H.SHOW_TEXT |
                  H.SHOW_PROCESSING_INSTRUCTION |
                  H.SHOW_CDATA_SECTION,
                null
              );
            },
            At = function (e) {
              return (
                e instanceof B &&
                ("string" != typeof e.nodeName ||
                  "string" != typeof e.textContent ||
                  "function" != typeof e.removeChild ||
                  !(e.attributes instanceof z) ||
                  "function" != typeof e.removeAttribute ||
                  "function" != typeof e.setAttribute ||
                  "string" != typeof e.namespaceURI ||
                  "function" != typeof e.insertBefore ||
                  "function" != typeof e.hasChildNodes)
              );
            },
            Nt = function (e) {
              return "function" == typeof b && e instanceof b;
            },
            bt = function (e, t, n) {
              pe[e] &&
                u(pe[e], (e) => {
                  e.call(o, t, n, ct);
                });
            },
            St = function (e) {
              let t = null;
              if ((bt("beforeSanitizeElements", e, null), At(e)))
                return Tt(e), !0;
              const n = lt(e.nodeName);
              if (
                (bt("uponSanitizeElement", e, { tagName: n, allowedTags: Ne }),
                e.hasChildNodes() &&
                  !Nt(e.firstElementChild) &&
                  _(/<[/\w]/g, e.innerHTML) &&
                  _(/<[/\w]/g, e.textContent))
              )
                return Tt(e), !0;
              if (e.nodeType === J) return Tt(e), !0;
              if (Me && e.nodeType === Q && _(/<[/\w]/g, e.data))
                return Tt(e), !0;
              if (!Ne[n] || Ce[n]) {
                if (!Ce[n] && wt(n)) {
                  if (
                    we.tagNameCheck instanceof RegExp &&
                    _(we.tagNameCheck, n)
                  )
                    return !1;
                  if (we.tagNameCheck instanceof Function && we.tagNameCheck(n))
                    return !1;
                }
                if (Ge && !Xe[n]) {
                  const t = re(e) || e.parentNode,
                    n = oe(e) || e.childNodes;
                  if (n && t) {
                    for (let o = n.length - 1; o >= 0; --o) {
                      const r = X(n[o], !0);
                      (r.__removalCount = (e.__removalCount || 0) + 1),
                        t.insertBefore(r, ne(e));
                    }
                  }
                }
                return Tt(e), !0;
              }
              return e instanceof R &&
                !(function (e) {
                  let t = re(e);
                  (t && t.tagName) ||
                    (t = { namespaceURI: tt, tagName: "template" });
                  const n = f(e.tagName),
                    o = f(t.tagName);
                  return (
                    !!ot[e.namespaceURI] &&
                    (e.namespaceURI === Qe
                      ? t.namespaceURI === et
                        ? "svg" === n
                        : t.namespaceURI === Je
                        ? "svg" === n && ("annotation-xml" === o || pt[o])
                        : Boolean(ht[n])
                      : e.namespaceURI === Je
                      ? t.namespaceURI === et
                        ? "math" === n
                        : t.namespaceURI === Qe
                        ? "math" === n && ft[o]
                        : Boolean(gt[n])
                      : e.namespaceURI === et
                      ? !(t.namespaceURI === Qe && !ft[o]) &&
                        !(t.namespaceURI === Je && !pt[o]) &&
                        !gt[n] &&
                        (dt[n] || !ht[n])
                      : !(
                          "application/xhtml+xml" !== it || !ot[e.namespaceURI]
                        ))
                  );
                })(e)
                ? (Tt(e), !0)
                : ("noscript" !== n && "noembed" !== n && "noframes" !== n) ||
                  !_(/<\/no(script|embed|frames)/i, e.innerHTML)
                ? (ke &&
                    e.nodeType === Z &&
                    ((t = e.textContent),
                    u([fe, de, he], (e) => {
                      t = g(t, e, " ");
                    }),
                    e.textContent !== t &&
                      (p(o.removed, { element: e.cloneNode() }),
                      (e.textContent = t))),
                  bt("afterSanitizeElements", e, null),
                  !1)
                : (Tt(e), !0);
            },
            Rt = function (e, t, n) {
              if (Be && ("id" === t || "name" === t) && (n in r || n in st))
                return !1;
              if (ve && !Le[t] && _(ge, t));
              else if (De && _(Te, t));
              else if (!Se[t] || Le[t]) {
                if (
                  !(
                    (wt(e) &&
                      ((we.tagNameCheck instanceof RegExp &&
                        _(we.tagNameCheck, e)) ||
                        (we.tagNameCheck instanceof Function &&
                          we.tagNameCheck(e))) &&
                      ((we.attributeNameCheck instanceof RegExp &&
                        _(we.attributeNameCheck, t)) ||
                        (we.attributeNameCheck instanceof Function &&
                          we.attributeNameCheck(t)))) ||
                    ("is" === t &&
                      we.allowCustomizedBuiltInElements &&
                      ((we.tagNameCheck instanceof RegExp &&
                        _(we.tagNameCheck, n)) ||
                        (we.tagNameCheck instanceof Function &&
                          we.tagNameCheck(n))))
                  )
                )
                  return !1;
              } else if (Ve[t]);
              else if (_(Ae, g(n, Ee, "")));
              else if (
                ("src" !== t && "xlink:href" !== t && "href" !== t) ||
                "script" === e ||
                0 !== T(n, "data:") ||
                !$e[e]
              ) {
                if (Oe && !_(ye, g(n, Ee, "")));
                else if (n) return !1;
              } else;
              return !0;
            },
            wt = function (e) {
              return "annotation-xml" !== e && h(e, _e);
            },
            Ct = function (e) {
              bt("beforeSanitizeAttributes", e, null);
              const { attributes: t } = e;
              if (!t) return;
              const n = {
                attrName: "",
                attrValue: "",
                keepAttr: !0,
                allowedAttributes: Se,
              };
              let r = t.length;
              for (; r--; ) {
                const i = t[r],
                  { name: a, namespaceURI: l, value: c } = i,
                  s = lt(a);
                let p = "value" === a ? c : y(c);
                if (
                  ((n.attrName = s),
                  (n.attrValue = p),
                  (n.keepAttr = !0),
                  (n.forceKeepAttr = void 0),
                  bt("uponSanitizeAttribute", e, n),
                  (p = n.attrValue),
                  Me && _(/((--!?|])>)|<\/(style|title)/i, p))
                ) {
                  yt(a, e);
                  continue;
                }
                if (n.forceKeepAttr) continue;
                if ((yt(a, e), !n.keepAttr)) continue;
                if (!xe && _(/\/>/i, p)) {
                  yt(a, e);
                  continue;
                }
                ke &&
                  u([fe, de, he], (e) => {
                    p = g(p, e, " ");
                  });
                const f = lt(e.nodeName);
                if (Rt(f, s, p)) {
                  if (
                    (!We ||
                      ("id" !== s && "name" !== s) ||
                      (yt(a, e), (p = "user-content-" + p)),
                    ie &&
                      "object" == typeof G &&
                      "function" == typeof G.getAttributeType)
                  )
                    if (l);
                    else
                      switch (G.getAttributeType(f, s)) {
                        case "TrustedHTML":
                          p = ie.createHTML(p);
                          break;
                        case "TrustedScriptURL":
                          p = ie.createScriptURL(p);
                      }
                  try {
                    l ? e.setAttributeNS(l, a, p) : e.setAttribute(a, p),
                      At(e) ? Tt(e) : m(o.removed);
                  } catch (e) {}
                }
              }
              bt("afterSanitizeAttributes", e, null);
            },
            Lt = function e(t) {
              let n = null;
              const o = _t(t);
              for (bt("beforeSanitizeShadowDOM", t, null); (n = o.nextNode()); )
                bt("uponSanitizeShadowNode", n, null),
                  St(n) || (n.content instanceof s && e(n.content), Ct(n));
              bt("afterSanitizeShadowDOM", t, null);
            };
          return (
            (o.sanitize = function (e) {
              let t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : {},
                n = null,
                r = null,
                i = null,
                l = null;
              if (
                ((nt = !e),
                nt && (e = "\x3c!--\x3e"),
                "string" != typeof e && !Nt(e))
              ) {
                if ("function" != typeof e.toString)
                  throw A("toString is not a function");
                if ("string" != typeof (e = e.toString()))
                  throw A("dirty is not a string, aborting");
              }
              if (!o.isSupported) return e;
              if (
                (Ue || mt(t),
                (o.removed = []),
                "string" == typeof e && (Ye = !1),
                Ye)
              ) {
                if (e.nodeName) {
                  const t = lt(e.nodeName);
                  if (!Ne[t] || Ce[t])
                    throw A(
                      "root node is forbidden and cannot be sanitized in-place"
                    );
                }
              } else if (e instanceof b)
                (n = Et("\x3c!----\x3e")),
                  (r = n.ownerDocument.importNode(e, !0)),
                  (r.nodeType === V && "BODY" === r.nodeName) ||
                  "HTML" === r.nodeName
                    ? (n = r)
                    : n.appendChild(r);
              else {
                if (!Fe && !ke && !Ie && -1 === e.indexOf("<"))
                  return ie && ze ? ie.createHTML(e) : e;
                if (((n = Et(e)), !n)) return Fe ? null : ze ? ae : "";
              }
              n && Pe && Tt(n.firstChild);
              const c = _t(Ye ? e : n);
              for (; (i = c.nextNode()); )
                St(i) || (i.content instanceof s && Lt(i.content), Ct(i));
              if (Ye) return e;
              if (Fe) {
                if (He)
                  for (l = se.call(n.ownerDocument); n.firstChild; )
                    l.appendChild(n.firstChild);
                else l = n;
                return (
                  (Se.shadowroot || Se.shadowrootmode) &&
                    (l = me.call(a, l, !0)),
                  l
                );
              }
              let m = Ie ? n.outerHTML : n.innerHTML;
              return (
                Ie &&
                  Ne["!doctype"] &&
                  n.ownerDocument &&
                  n.ownerDocument.doctype &&
                  n.ownerDocument.doctype.name &&
                  _(q, n.ownerDocument.doctype.name) &&
                  (m = "<!DOCTYPE " + n.ownerDocument.doctype.name + ">\n" + m),
                ke &&
                  u([fe, de, he], (e) => {
                    m = g(m, e, " ");
                  }),
                ie && ze ? ie.createHTML(m) : m
              );
            }),
            (o.setConfig = function () {
              mt(
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : {}
              ),
                (Ue = !0);
            }),
            (o.clearConfig = function () {
              (ct = null), (Ue = !1);
            }),
            (o.isValidAttribute = function (e, t, n) {
              ct || mt({});
              const o = lt(e),
                r = lt(t);
              return Rt(o, r, n);
            }),
            (o.addHook = function (e, t) {
              "function" == typeof t && ((pe[e] = pe[e] || []), p(pe[e], t));
            }),
            (o.removeHook = function (e) {
              if (pe[e]) return m(pe[e]);
            }),
            (o.removeHooks = function (e) {
              pe[e] && (pe[e] = []);
            }),
            (o.removeAllHooks = function () {
              pe = {};
            }),
            o
          );
        })();
        return ne;
      });
      //# sourceMappingURL=purify.min.js.map

      /* --- app.js (inline) --- */
      /* ===== Bundled by Splitter (local app code) ===== */
      ("use strict");

      // ======== App State ========
      const state = {
        questions: [],
        currentQuestion: 0,
        score: 0,
        timeLeft: 30,
        questionTime: 30,
        timerId: null,
        isPaused: false,
        answeredQuestions: [],
        lastWrong: [],
        numeralType: "arabic", // default for English
        shuffledMaps: [],
        optionsLayout: "2x2",
      };

      const quizConfig = {
        title: "General Quiz - Lite",
        instructions:
          "Select the correct answer for each question before time runs out.",
      };

      const STORAGE_KEY = "quiz-progress-lite-en-v1";

      const fmtArabic = new Intl.NumberFormat("ar-EG"); // Eastern digits
      const fmtLatin = new Intl.NumberFormat("en-US"); // Latin digits
      function formatNumber(n) {
        return state.numeralType === "eastern"
          ? fmtArabic.format(n)
          : fmtLatin.format(n);
      }

      // ======== Sanitization & Text Utilities ========
      function sanitizeHTML(html) {
        if (!window.DOMPurify) return html || "";
        return DOMPurify.sanitize(html || "", {
          ADD_TAGS: [
            "a",
            "u",
            "mark",
            "blockquote",
            "hr",
            "pre",
            "code",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "ul",
            "ol",
            "li",
            "img",
            "table",
            "thead",
            "tbody",
            "tr",
            "td",
            "th",
            "p",
            "span",
            "div",
            "br",
            "sub",
            "sup",
            "strong",
            "em",
          ],
          ALLOWED_ATTR: [
            "src",
            "alt",
            "style",
            "class",
            "rowspan",
            "colspan",
            "href",
            "target",
            "rel",
            "dir",
            "width",
            "height",
          ],
          ALLOW_DATA_ATTR: false,
          FORBID_ATTR: ["onerror", "onclick"],
        });
      }

      const EASTERN = ["Ÿ†", "Ÿ°", "Ÿ¢", "Ÿ£", "Ÿ§", "Ÿ•", "Ÿ¶", "Ÿß", "Ÿ®", "Ÿ©"];

      function convertNumeralsInText(text) {
        if (!text || typeof text !== "string") return text;
        if (state.numeralType === "eastern")
          return text.replace(/\d/g, (d) => EASTERN[d]);
        return text.replace(/[Ÿ†-Ÿ©]/g, (d) => EASTERN.indexOf(d));
      }

      function applyNumeralTypeToPage() {
        const SKIP = new Set(["SCRIPT", "STYLE", "TEXTAREA", "INPUT"]);
        function walk(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            node.nodeValue = convertNumeralsInText(node.nodeValue);
          } else if (
            node.nodeType === Node.ELEMENT_NODE &&
            !SKIP.has(node.tagName)
          ) {
            for (let i = 0; i < node.childNodes.length; i++)
              walk(node.childNodes[i]);
          }
        }
        const targets = [
          document.body,
          document.getElementById("readingText"),
          document.getElementById("question"),
          document.getElementById("options"),
          document.getElementById("scoreBoard"),
          document.getElementById("quizTitle"),
          document.getElementById("instructions"),
          document.getElementById("quizFooter"),
        ];
        targets.forEach((el) => {
          if (el) walk(el);
        });

        const fs = document.getElementById("finalScore");
        const tq = document.getElementById("totalQuestions");
        if (fs) fs.textContent = convertNumeralsInText(fs.textContent);
        if (tq) tq.textContent = convertNumeralsInText(tq.textContent);
      }

      // Strict plain-text -> HTML (supports ///, //, and lead-in bullets/numbers)
      function plainToHTMLStrict(src) {
        if (!src || typeof src !== "string") return "";
        const ESC = (s) =>
          s.replace(
            /[&<>]/g,
            (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" }[m])
          );
        const lines = src.split(/\r?\n/);
        const out = [];
        for (let raw of lines) {
          let s = raw.trim();
          if (!s) {
            out.push("<p>&nbsp;</p>");
            continue;
          }
          if (/^\/\/\/+$/.test(s)) {
            out.push("<hr>");
            continue;
          }
          s = ESC(s).replace(/(?:\s*\/\/\s*)+/g, "<br>");
          const m = s.match(
            /^(\*+|[\-\u2212\u2013\u2014]|[\(\[]?[0-9Ÿ†-Ÿ©]+[\)\.\-:]|[IVXLC]+[\)\.\:])\s+(.*)$/i
          );
          if (m) {
            const head = m[1],
              rest = m[2];
            s = `<span class="lead-in">${head}</span> ${rest}`;
          }
          out.push(`<p>${s}</p>`);
        }
        if (!out.length) out.push("<p>&nbsp;</p>");
        return out.join("");
      }

      // Uses HTML when present; otherwise converts plain text with shortcuts
      function formatQuizContent(html) {
        if (!html || typeof html !== "string") return "";
        const looksHTML = /<\/?[a-z][\s\S]*>/i.test(html);
        const rendered = looksHTML ? html : plainToHTMLStrict(html);

        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = rendered;

        (function walk(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            node.nodeValue = convertNumeralsInText(node.nodeValue);
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            for (let i = 0; i < node.childNodes.length; i++)
              walk(node.childNodes[i]);
          }
        })(tempDiv);

        return sanitizeHTML(tempDiv.innerHTML);
      }

      // Title & instructions helpers (HTML allowed; // and /// in plain)
      function formatHeader(input) {
        if (!input || typeof input !== "string") return "";
        const looksHTML = /<\/?[a-z][\s\S]*>/i.test(input);
        if (looksHTML) return sanitizeHTML(input);
        let s = input.replace(/(?:\s*\/\/\s*)+/g, "<br>");
        return sanitizeHTML(s);
      }
      function formatSubheader(input) {
        if (!input || typeof input !== "string") return "";
        const looksHTML = /<\/?[a-z][\s\S]*>/i.test(input);
        if (looksHTML) return sanitizeHTML(input);
        const out = input
          .split(/\r?\n/)
          .map((line) => {
            const t = line.trim();
            if (/^\/\/\/+$/.test(t)) return "<hr>";
            return line.replace(/(?:\s*\/\/\s*)+/g, "<br>");
          })
          .join("<br>");
        return sanitizeHTML(out);
      }

      // ======== Persistence ========
      function persist() {
        try {
          const payload = {
            currentQuestion: state.currentQuestion,
            score: state.score,
            timeLeft: state.timeLeft,
            questionTime: state.questionTime,
            answeredQuestions: state.answeredQuestions,
            lastWrong: state.lastWrong,
            numeralType: state.numeralType,
            shuffledMaps: state.shuffledMaps,
            questions: state.questions,
            optionsLayout: state.optionsLayout,
          };
          localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        } catch {}
      }

      function restore() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return;
          const p = JSON.parse(raw);
          [
            "currentQuestion",
            "score",
            "timeLeft",
            "questionTime",
            "numeralType",
            [
              "currentQuestion",
              "score",
              "timeLeft",
              "questionTime",
              "numeralType",
              "optionsLayout",
            ],
          ].forEach((k) => {
            if (p[k] !== undefined) state[k] = p[k];
          });
          if (Array.isArray(p.answeredQuestions))
            state.answeredQuestions = p.answeredQuestions;
          if (Array.isArray(p.lastWrong)) state.lastWrong = p.lastWrong;
          if (Array.isArray(p.shuffledMaps))
            state.shuffledMaps = p.shuffledMaps;
          if (Array.isArray(p.questions) && p.questions.length)
            state.questions = p.questions;
        } catch {}
      }

      // ======== Quiz Core ========
      function shuffleOptionsOnce(qIndex) {
        if (state.shuffledMaps[qIndex]) return state.shuffledMaps[qIndex];
        const q = state.questions[qIndex];
        const map = (q.options || []).map((_, i) => i);
        for (let i = map.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [map[i], map[j]] = [map[j], map[i]];
        }
        state.shuffledMaps[qIndex] = map;
        return map;
      }

      function startTimer() {
        clearInterval(state.timerId);
        const endAt = Date.now() + state.questionTime * 1000;
        state.timerId = setInterval(() => {
          if (state.isPaused) return;
          const remain = Math.max(0, Math.ceil((endAt - Date.now()) / 1000));
          state.timeLeft = remain;
          updateTimerDisplay();
          if (remain <= 0) {
            clearInterval(state.timerId);
            nextQuestion();
          }
        }, 200);
      }

      function updateTimerDisplay() {
        document.getElementById(
          "timer"
        ).textContent = `Time left: ${formatNumber(state.timeLeft)} seconds`;
      }
      function updateQuestionCounter() {
        document.getElementById(
          "questionCounter"
        ).textContent = `Question ${formatNumber(
          state.currentQuestion + 1
        )} of ${formatNumber(state.questions.length)}`;
      }
      function updateScoreCounter() {
        document.getElementById(
          "scoreCounter"
        ).textContent = `Score: ${formatNumber(state.score)} of ${formatNumber(
          state.questions.length
        )}`;
      }

      function init(skipRestore = false) {
        if (!skipRestore) restore();

        document.getElementById("numeralType").value = state.numeralType;
        document.getElementById("questionTime").value = state.questionTime;

        // Title & instructions (support HTML/plain shortcuts)
        document.getElementById("quizTitle").innerHTML = formatHeader(
          quizConfig.title
        );
        document.getElementById("instructions").innerHTML = formatSubheader(
          quizConfig.instructions
        );

        if (state.questions.length === 0) {
          document.getElementById(
            "questionCounter"
          ).textContent = `Question ${formatNumber(0)} of ${formatNumber(0)}`;
          document.getElementById(
            "timer"
          ).textContent = `Time left: ${formatNumber(state.timeLeft)} seconds`;
          document.getElementById(
            "scoreCounter"
          ).textContent = `Score: ${formatNumber(0)} of ${formatNumber(0)}`;
          return;
        }

        if (
          !Array.isArray(state.answeredQuestions) ||
          state.answeredQuestions.length !== state.questions.length
        ) {
          state.answeredQuestions = new Array(state.questions.length).fill(
            null
          );
          state.lastWrong = new Array(state.questions.length).fill(null);
        }
        showQuestion();
      }

      function canApplyChosenLayout(layout, optionCount) {
        if (layout === "4x1") {
          return (
            optionCount === 4 && window.matchMedia("(min-width: 769px)").matches
          );
        }
        return false;
      }
      function applyLayoutSafely(optionCount) {
        const el = document.getElementById("options");
        if (!el) return;
        if (canApplyChosenLayout(state.optionsLayout, optionCount)) {
          el.dataset.layout = "4x1";
        } else {
          delete el.dataset.layout; // ÿ±ÿ¨Ÿàÿπ ŸÅŸàÿ±Ÿä ŸÑŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
        }
      }

      function showQuestion() {
        clearInterval(state.timerId);
        state.timeLeft = state.questionTime;

        const readingTextElement = document.getElementById("readingText");
        const questionElement = document.getElementById("question");
        const optionsElement = document.getElementById("options");

        if (state.currentQuestion >= state.questions.length) {
          showResult();
          return;
        }

        const q = state.questions[state.currentQuestion];
        // Ensure valid correct answer index
        if (
          !Array.isArray(q.options) ||
          q.options.length === 0 ||
          typeof q.correct !== "number" ||
          q.correct < 0 ||
          q.correct >= q.options.length
        ) {
          q.correct = 0;
        }

        // ----- ÿßŸÑŸÇÿ±ÿßÿ°ÿ© -----
        readingTextElement.innerHTML = "";
        let readingTextContent = "",
          readingImageSrc = null;
        if (q.reading) {
          readingTextContent = q.reading.text || "";
          readingImageSrc = q.reading.image || null;
        } else if (q.readingText) {
          readingTextContent =
            typeof q.readingText === "string"
              ? q.readingText
              : q.readingText.text || "";
          readingImageSrc =
            typeof q.readingText === "object"
              ? q.readingText.image || null
              : null;
        } else if (q.paragraph) {
          readingTextContent = q.paragraph;
          readingImageSrc = q.paragraphImage || null;
        }

        if (readingTextContent || readingImageSrc) {
          readingTextElement.style.display = "block";
          if (readingTextContent) {
            const d = document.createElement("div");
            d.className = "reading-text-content";
            d.innerHTML = formatQuizContent(readingTextContent);
            readingTextElement.appendChild(d);
          }
          if (readingImageSrc) {
            const img = document.createElement("img");
            img.src = readingImageSrc;
            img.className = "reading-text-image";
            img.alt = "ÿµŸàÿ±ÿ© ÿßŸÑŸÜÿµ ÿßŸÑŸÇÿ±ÿßÿ¶Ÿä";
            readingTextElement.appendChild(img);
            img.alt = "Reading image";
            img.loading = "lazy";
            img.decoding = "async";
          }
        } else {
          readingTextElement.style.display = "none";
        }

        // ----- ÿßŸÑÿ≥ÿ§ÿßŸÑ -----
        questionElement.innerHTML = "";
        const questionContent = document.createElement("div");
        questionContent.className = "question-content";

        if (q.question?.text) {
          const d = document.createElement("div");
          d.className = "question-text";
          d.innerHTML = formatQuizContent(q.question.text);
          questionContent.appendChild(d);
        }
        if (q.question?.image) {
          const i = document.createElement("img");
          i.src = q.question.image;
          i.className = "question-image";
          i.alt = "Question image";
          i.loading = "lazy";
          i.decoding = "async";
          questionContent.appendChild(i);
        }
        questionElement.appendChild(questionContent);

        // ----- ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™ -----
        optionsElement.innerHTML = "";
        optionsElement.setAttribute("role", "radiogroup");
        if (!q.options || q.options.length === 0) {
          console.warn("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿÆŸäÿßÿ±ÿßÿ™ ŸÑŸáÿ∞ÿß ÿßŸÑÿ≥ÿ§ÿßŸÑ");
          return;
        }

        const map = shuffleOptionsOnce(state.currentQuestion);
        const valid = [];
        map.forEach((origIdx) => {
          const opt = q.options[origIdx];
          if (!opt || (!opt.text && !opt.image)) return;

          const wrap = document.createElement("div");
          wrap.className = "option";
          wrap.setAttribute("role", "radio");
          wrap.setAttribute("tabindex", "0");
          wrap.setAttribute("aria-checked", "false");

          const content = document.createElement("div");
          content.className = "option-content";

          if (opt.image) {
            const img = document.createElement("img");
            img.src = opt.image;
            img.className = "option-image";
            img.alt = "Option image";
            img.loading = "lazy";
            img.decoding = "async";
            content.appendChild(img);
          }
          if (opt.text) {
            const span = document.createElement("span");
            span.className = "option-text";
            span.innerHTML = formatQuizContent(opt.text);
            content.appendChild(span);
          }

          wrap.appendChild(content);

          if (state.answeredQuestions[state.currentQuestion] !== null) {
            wrap.setAttribute("aria-disabled", "true");
            if (origIdx === q.correct) wrap.classList.add("correct");
            if (
              state.answeredQuestions[state.currentQuestion] === false &&
              state.lastWrong[state.currentQuestion] === origIdx
            ) {
              wrap.classList.add("wrong");
            }
          }

          wrap.onclick = () => checkAnswer(origIdx);
          wrap.onkeydown = (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              checkAnswer(origIdx);
              return;
            }
            if (
              e.key === "ArrowRight" ||
              e.key === "ArrowDown" ||
              e.key === "ArrowLeft" ||
              e.key === "ArrowUp"
            ) {
              const items = Array.from(
                document.querySelectorAll("#options .option")
              );
              const idx = items.indexOf(wrap);
              let next = idx;
              if (e.key === "ArrowRight" || e.key === "ArrowDown") next++;
              else next--;
              if (next < 0) next = items.length - 1;
              if (next >= items.length) next = 0;
              const el = items[next];
              if (el) el.focus();
            }
          };

          valid.push(wrap);
          applyLayoutSafely(valid.length);
        });

        optionsElement.classList.remove(
          "options-row",
          "options-two",
          "options-three"
        );
        if (valid.length <= 3) {
          optionsElement.classList.add("options-row");
          if (valid.length === 2) optionsElement.classList.add("options-two");
          else if (valid.length === 3)
            optionsElement.classList.add("options-three");
        }
        valid.forEach((v) => optionsElement.appendChild(v));

        // ÿ£ÿ≤ÿ±ÿßÿ±/ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ™ŸÇÿØŸëŸÖ + ÿßŸÑŸÖÿ§ÿ¥ÿ±ÿßÿ™
        document.getElementById("prevBtn").disabled =
          state.currentQuestion === 0;
        document.getElementById("nextBtn").disabled = false;

        const progressEl = document.getElementById("progress");
        if (progressEl) {
          const total = Array.isArray(state.questions)
            ? state.questions.length
            : 0;
          const pct = total > 0 ? (state.currentQuestion / total) * 100 : 0;
          progressEl.style.width = pct + "%"; // ÿßŸÜÿ™ÿ®Ÿá ÿ£ŸÜŸáÿß % ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©
        }

        updateQuestionCounter();
        updateScoreCounter();
        updateTimerDisplay();
        startTimer();
        persist();
      }

      function checkAnswer(selectedIndex) {
        if (state.answeredQuestions[state.currentQuestion] !== null) return;
        const q = state.questions[state.currentQuestion];
        document.querySelectorAll(".option").forEach((o) => {
          o.setAttribute("aria-disabled", "true");
        });
        const correctIndex = q.correct;
        if (selectedIndex === correctIndex) {
          state.score++;
          state.answeredQuestions[state.currentQuestion] = true;
        } else {
          state.answeredQuestions[state.currentQuestion] = false;
          state.lastWrong[state.currentQuestion] = selectedIndex;
        }
        const map = state.shuffledMaps[state.currentQuestion] || [];
        document.querySelectorAll(".option").forEach((el, i) => {
          const origIdx = map[i];
          if (origIdx === correctIndex) el.classList.add("correct");
          if (
            state.answeredQuestions[state.currentQuestion] === false &&
            origIdx === state.lastWrong[state.currentQuestion]
          )
            el.classList.add("wrong");
          el.setAttribute("aria-checked", String(origIdx === selectedIndex));
        });
        updateScoreCounter();
        persist();
        if (state.currentQuestion < state.questions.length - 1)
          setTimeout(nextQuestion, 1000);
        else setTimeout(showResult, 1000);
      }

      function nextQuestion() {
        if (state.currentQuestion >= state.questions.length - 1) {
          showResult();
          return;
        }
        state.currentQuestion++;
        showQuestion();
      }
      function previousQuestion() {
        if (state.currentQuestion > 0) {
          state.currentQuestion--;
          showQuestion();
        }
      }

      function showResult() {
        clearInterval(state.timerId);
        document.querySelector(".quiz-box").style.display = "none";
        document.getElementById("scoreBoard").style.display = "block";
        document.getElementById("teacherButtons").style.display = "none";
        document.getElementById("readingText").style.display = "none";
        document.getElementById("countersBox").style.display = "none";

        document.getElementById("finalScore").textContent = formatNumber(
          state.score
        );
        document.getElementById("totalQuestions").textContent = formatNumber(
          state.questions.length
        );

        applyNumeralTypeToPage();
        persist();
      }

      function restartQuiz() {
        state.currentQuestion = 0;
        state.score = 0;
        state.timeLeft = state.questionTime;
        state.answeredQuestions = new Array(state.questions.length).fill(null);
        state.lastWrong = new Array(state.questions.length).fill(null);
        document.querySelector(".quiz-box").style.display = "block";
        document.getElementById("scoreBoard").style.display = "none";
        document.getElementById("teacherButtons").style.display = "flex";
        document.getElementById("countersBox").style.display = "flex";
        const progress = document.getElementById("progress");
        if (progress) progress.style.width = "0%";
        document.querySelectorAll(".option").forEach((o) => {
          o.classList.remove("correct", "wrong");
          o.removeAttribute("aria-disabled");
        });
        showQuestion();
      }

      function togglePause() {
        state.isPaused = !state.isPaused;
        const b = document.getElementById("pauseBtn");
        b.textContent = state.isPaused ? "Resume" : "Pause";
        b.style.background = state.isPaused ? "#28a745" : "#ffc107";
      }

      function toggleSettingsPanel() {
        const p = document.getElementById("settingsPanel");
        p.style.display = p.style.display === "block" ? "none" : "block";
        persist();
      }

      function toggleConfigPanel() {
        const p = document.getElementById("configPanel");
        if (p.style.display === "block") {
          p.style.display = "none";
        } else {
          p.style.display = "block";
          document.getElementById("titleInput").value = quizConfig.title;
          document.getElementById("instructionsInput").value =
            quizConfig.instructions;
          document.getElementById("footerInput").value =
            document.getElementById("quizFooter").textContent;
        }
      }

      function saveConfig() {
        const newTitle = document.getElementById("titleInput").value?.trim();
        const newInstructions = document
          .getElementById("instructionsInput")
          .value?.trim();
        const newFooter = document.getElementById("footerInput").value?.trim();
        if (newTitle) {
          quizConfig.title = newTitle;
          document.getElementById("quizTitle").innerHTML =
            formatHeader(newTitle);
        }
        if (newInstructions) {
          quizConfig.instructions = newInstructions;
          document.getElementById("instructions").innerHTML =
            formatSubheader(newInstructions);
        }
        if (newFooter) {
          document.getElementById("quizFooter").innerHTML =
            sanitizeHTML(newFooter);
        }
        toggleConfigPanel();
        persist();
      }

      function changeNumeralType() {
        state.numeralType = document.getElementById("numeralType").value;
        updateQuestionCounter();
        updateScoreCounter();
        updateTimerDisplay();
        applyNumeralTypeToPage();
        persist();
      }

      function changeQuestionTime() {
        const v = parseInt(document.getElementById("questionTime").value, 10);
        if (v >= 5 && v <= 180) {
          state.questionTime = v;
          state.timeLeft = v;
          updateTimerDisplay();
          persist();
        }
      }

      function changeOptionsLayout() {
        const sel = document.getElementById("optionsLayout");
        const val = (sel && sel.value) || "2x2";
        state.optionsLayout = val === "4x1" ? "4x1" : "2x2";
        persist();
        showQuestion();
      }

      function cleanEasternNumerals() {
        if (!Array.isArray(state.questions)) return;
        function eastToLatin(t) {
          return (t || "")
            .toString()
            .replace(/[Ÿ†-Ÿ©]/g, (d) => EASTERN.indexOf(d));
        }
        state.questions.forEach((q) => {
          if (q.reading?.text) q.reading.text = eastToLatin(q.reading.text);
          if (
            q.readingText &&
            typeof q.readingText === "object" &&
            q.readingText.text
          )
            q.readingText.text = eastToLatin(q.readingText.text);
          if (q.paragraph) q.paragraph = eastToLatin(q.paragraph);
          if (q.question?.text) q.question.text = eastToLatin(q.question.text);
          if (Array.isArray(q.options))
            q.options.forEach((o) => {
              if (o?.text) o.text = eastToLatin(o.text);
            });
        });
        alert("‚úÖ Eastern digits cleaned successfully!");
        showQuestion();
        persist();
      }

      function loadQuestionsFromFile() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (evt) => {
            try {
              const data = JSON.parse(evt.target.result);
              if (!Array.isArray(data)) throw new Error("Invalid format");

              localStorage.removeItem(STORAGE_KEY);

              state.questions = JSON.parse(JSON.stringify(data));
              state.currentQuestion = 0;
              state.score = 0;
              state.timeLeft = state.questionTime;
              state.shuffledMaps = [];
              // normalize correctness indexes inside loaded data
              state.questions.forEach((qq) => {
                if (!Array.isArray(qq.options)) qq.options = [];
                if (
                  typeof qq.correct !== "number" ||
                  qq.correct < 0 ||
                  qq.correct >= qq.options.length
                ) {
                  qq.correct = 0;
                }
              });
              state.answeredQuestions = new Array(state.questions.length).fill(
                null
              );
              state.lastWrong = new Array(state.questions.length).fill(null);

              init(true);
              persist();
            } catch (err) {
              alert(
                "Error while loading questions. Please check the JSON format."
              );
              console.error(err);
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      function saveQuestionsToFile() {
        if (!Array.isArray(state.questions) || state.questions.length === 0) {
          alert("No questions to save!");
          return;
        }
        const dataStr = JSON.stringify(state.questions, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "quiz_questions.json";
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 100);
      }

      // ======== Edit Mode ========
      function toggleEditMode() {
        const editPanel = document.getElementById("editPanel");
        const quizBox = document.querySelector(".quiz-box");
        const countersBox = document.getElementById("countersBox");
        const readingText = document.getElementById("readingText");

        if (!Array.isArray(state.questions) || state.questions.length === 0) {
          alert("Please load questions first!");
          return;
        }

        if (editPanel.style.display === "block") {
          editPanel.style.display = "none";
          quizBox.style.display = "block";
          countersBox.style.display = "flex";
          const q = state.questions[state.currentQuestion];
          const hasReading = q && (q.reading || q.readingText || q.paragraph);
          readingText.style.display = hasReading ? "block" : "none";
          startTimer();
          return;
        }

        clearInterval(state.timerId);
        editPanel.style.display = "block";
        quizBox.style.display = "none";
        countersBox.style.display = "none";
        readingText.style.display = "none";

        populateEditForm();
      }

      function populateEditForm() {
        const q = state.questions[state.currentQuestion];
        if (!q) return;

        let readingText = "";
        let readingImage = null;
        if (q.reading) {
          readingText = q.reading.text || "";
          readingImage = q.reading.image || null;
        } else if (q.readingText) {
          readingText =
            typeof q.readingText === "string"
              ? q.readingText
              : q.readingText.text || "";
          readingImage =
            typeof q.readingText === "object"
              ? q.readingText.image || null
              : null;
        } else if (q.paragraph) {
          readingText = q.paragraph || "";
          readingImage = q.paragraphImage || null;
        }

        document.getElementById("editReadingText").value = readingText || "";
        const rPrev = document.getElementById("readingImagePreview");
        rPrev.src = readingImage || "";
        rPrev.style.display = readingImage ? "block" : "none";

        document.getElementById("editQuestionText").value =
          q.question && q.question.text ? q.question.text : "";
        const qPrev = document.getElementById("questionImagePreview");
        qPrev.src = q.question && q.question.image ? q.question.image : "";
        qPrev.style.display = q.question && q.question.image ? "block" : "none";

        for (let i = 0; i < 4; i++) {
          const opt =
            q.options && q.options[i]
              ? q.options[i]
              : { text: "", image: null };
          const t = document.getElementById("editOption" + (i + 1));
          const p = document.getElementById("optionImagePreview" + (i + 1));
          const c = document.getElementById("correct" + (i + 1));
          if (t) t.value = opt.text || "";
          if (p) {
            p.src = opt.image || "";
            p.style.display = opt.image ? "block" : "none";
          }
          if (c) c.checked = i === (q.correct || 0);
        }
      }

      function handleImageUpload(input, previewId, setter) {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          const data = e.target.result;
          const prev = document.getElementById(previewId);
          if (prev) {
            prev.src = data;
            prev.style.display = "block";
          }
          try {
            setter(data);
            persist();
          } catch {}
        };
        reader.readAsDataURL(file);
      }

      function attachEditPanelEvents() {
        const rImg = document.getElementById("editReadingImage");
        if (rImg)
          rImg.onchange = function () {
            const q = state.questions[state.currentQuestion];
            handleImageUpload(this, "readingImagePreview", (base64) => {
              if (q.reading) {
                q.reading.image = base64;
              } else if (q.readingText && typeof q.readingText === "object") {
                q.readingText.image = base64;
              } else {
                q.paragraphImage = base64;
              }
            });
          };

        const qImg = document.getElementById("editQuestionImage");
        if (qImg)
          qImg.onchange = function () {
            const q = state.questions[state.currentQuestion];
            if (!q.question) q.question = { text: "", image: null };
            handleImageUpload(this, "questionImagePreview", (base64) => {
              q.question.image = base64;
            });
          };

        for (let i = 1; i <= 4; i++) {
          const optImg = document.getElementById("editOptionImage" + i);
          if (optImg)
            optImg.onchange = (function (ii) {
              return function () {
                const q = state.questions[state.currentQuestion];
                if (!q.options) q.options = [];
                if (!q.options[ii - 1])
                  q.options[ii - 1] = { text: "", image: null };
                handleImageUpload(this, "optionImagePreview" + ii, (base64) => {
                  q.options[ii - 1].image = base64;
                });
              };
            })(i);

          const corr = document.getElementById("correct" + i);
          if (corr)
            corr.onchange = (function (ii) {
              return function () {
                if (!this.checked) return;
                for (let j = 1; j <= 4; j++) {
                  const c = document.getElementById("correct" + j);
                  if (c) c.checked = j === ii;
                }
                const q = state.questions[state.currentQuestion];
                q.correct = ii - 1;
                persist();
              };
            })(i);
        }
      }

      function saveEdit() {
        const q = state.questions[state.currentQuestion];
        if (!q) return;

        const readingText = (
          document.getElementById("editReadingText").value || ""
        ).trim();
        const questionText = (
          document.getElementById("editQuestionText").value || ""
        ).trim();
        const options = [
          (document.getElementById("editOption1").value || "").trim(),
          (document.getElementById("editOption2").value || "").trim(),
          (document.getElementById("editOption3").value || "").trim(),
          (document.getElementById("editOption4").value || "").trim(),
        ];
        const nonEmpty = options.filter(Boolean).length;
        const correctIndex = [1, 2, 3, 4]
          .map((i) =>
            document.getElementById("correct" + i).checked ? i - 1 : -1
          )
          .find((x) => x !== -1);

        if (!questionText) {
          alert("Please enter the question text!");
          return;
        }
        if (nonEmpty < 2) {
          alert("Please enter at least two non-empty options!");
          return;
        }
        if (
          correctIndex === undefined ||
          correctIndex < 0 ||
          !options[correctIndex]
        ) {
          alert(
            "Please select one correct answer, and make sure it is not empty!"
          );
          return;
        }

        if (q.reading) {
          q.reading.text = readingText;
        } else if (q.readingText) {
          if (typeof q.readingText === "string") q.readingText = readingText;
          else q.readingText.text = readingText;
        } else {
          q.paragraph = readingText;
        }

        if (!q.question) q.question = { text: "", image: null };
        q.question.text = questionText;

        if (!Array.isArray(q.options)) q.options = [];
        for (let i = 0; i < 4; i++) {
          if (!q.options[i]) q.options[i] = { text: "", image: null };
          q.options[i].text = options[i] || "";
        }
        q.correct = correctIndex;

        document.getElementById("editPanel").style.display = "none";
        document.querySelector(".quiz-box").style.display = "block";
        document.getElementById("countersBox").style.display = "flex";

        const hasReading =
          q && (q.reading || q.readingText || q.paragraph || q.paragraphImage);
        document.getElementById("readingText").style.display = hasReading
          ? "block"
          : "none";

        showQuestion();
        persist();
      }

      function cancelEdit() {
        document.getElementById("editPanel").style.display = "none";
        document.querySelector(".quiz-box").style.display = "block";
        document.getElementById("countersBox").style.display = "flex";
        const q = state.questions[state.currentQuestion];
        const hasReading =
          q && (q.reading || q.readingText || q.paragraph || q.paragraphImage);
        document.getElementById("readingText").style.display = hasReading
          ? "block"
          : "none";
        startTimer();
      }

      function addNewQuestion() {
        const newQ = {
          reading: { text: "", image: null },
          question: { text: "", image: null },
          options: [
            { text: "", image: null },
            { text: "", image: null },
            { text: "", image: null },
            { text: "", image: null },
          ],
          correct: 0,
        };
        state.questions.push(newQ);
        state.currentQuestion = state.questions.length - 1;
        if (
          !Array.isArray(state.answeredQuestions) ||
          state.answeredQuestions.length !== state.questions.length
        ) {
          state.answeredQuestions = new Array(state.questions.length).fill(
            null
          );
          state.lastWrong = new Array(state.questions.length).fill(null);
        } else {
          state.answeredQuestions.push(null);
          state.lastWrong.push(null);
        }
        document.getElementById("editPanel").style.display = "none";
        document.querySelector(".quiz-box").style.display = "block";
        document.getElementById("countersBox").style.display = "flex";
        showQuestion();
        persist();
      }

      function deleteCurrentQuestion() {
        if (!Array.isArray(state.questions) || state.questions.length <= 1) {
          alert("Cannot delete the only question!");
          return;
        }
        if (!confirm("Are you sure you want to delete this question?")) return;

        state.questions.splice(state.currentQuestion, 1);
        if (Array.isArray(state.answeredQuestions))
          state.answeredQuestions.splice(state.currentQuestion, 1);
        if (Array.isArray(state.lastWrong))
          state.lastWrong.splice(state.currentQuestion, 1);
        if (Array.isArray(state.shuffledMaps))
          state.shuffledMaps.splice(state.currentQuestion, 1);

        if (state.currentQuestion >= state.questions.length)
          state.currentQuestion = state.questions.length - 1;

        document.getElementById("editPanel").style.display = "none";
        document.querySelector(".quiz-box").style.display = "block";
        document.getElementById("countersBox").style.display = "flex";
        const q = state.questions[state.currentQuestion];
        const hasReading = q && (q.reading || q.readingText || q.paragraph);
        document.getElementById("readingText").style.display = hasReading
          ? "block"
          : "none";
        showQuestion();
        persist();
      }

      window.addEventListener("load", attachEditPanelEvents);

      // ======== Save Student Version (Lite) ========
      // ======== ÿ≠ŸÅÿ∏ ŸÜÿ≥ÿÆÿ© ÿßŸÑÿ∑ÿßŸÑÿ® (ÿ®ÿØŸàŸÜ MathJax) ‚Äì English/Arabic Lite ========
      function saveAppForOfflineUse() {
        try {
          const teacherHTML = document.documentElement.cloneNode(true);
          const doc = teacherHTML.ownerDocument;

          // ÿ£ÿÆŸÅŸê ÿπŸÜÿßÿµÿ± ÿßŸÑŸÖÿπŸÑŸÖ ŸÖŸÜ ŸÜÿ≥ÿÆÿ© ÿßŸÑÿ∑ÿßŸÑÿ®
          const removeSelectors = [
            ".config-btn",
            ".buttons-container",
            ".settings-panel",
            ".config-panel",
            "#editPanel",
            "#editButton",
            "#settingsBtn",
            "#loadButton",
            "#saveQuestionsButton",
            "#saveAppButton",
            "#resetProgressBtn",
          ];
          removeSelectors.forEach((sel) =>
            teacherHTML.querySelectorAll(sel).forEach((el) => el.remove())
          );

          // ÿ≠ÿßŸÑÿ© ÿπÿ±ÿ∂ ÿßŸÑŸàÿßÿ¨Ÿáÿßÿ™ ŸÅŸä ÿßŸÑÿ∑ÿßŸÑÿ®
          const scoreBoard = teacherHTML.querySelector("#scoreBoard");
          if (scoreBoard) scoreBoard.style.display = "none";
          const quizBox = teacherHTML.querySelector(".quiz-box");
          if (quizBox) quizBox.style.display = "block";
          const counters = teacherHTML.querySelector("#countersBox");
          if (counters) counters.style.display = "flex";
          const readingTextBox = teacherHTML.querySelector("#readingText");
          if (readingTextBox) readingTextBox.style.display = "none";

          // ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ + ÿßŸÑÿ™ÿ±ŸÇŸäŸÖ
          const cleanQuestions = JSON.parse(
            JSON.stringify(state.questions ?? [])
          );
          const numeral =
            state.numeralType === "eastern" ? "eastern" : "arabic";
          const qTime = Number(state.questionTime) || 30;
          const layoutChoice = state.optionsLayout === "4x1" ? "4x1" : "2x2";

          const EAST = ["Ÿ†", "Ÿ°", "Ÿ¢", "Ÿ£", "Ÿ§", "Ÿ•", "Ÿ¶", "Ÿß", "Ÿ®", "Ÿ©"];
          const toEastern = (s) =>
            (s ?? "").toString().replace(/\d/g, (d) => EAST[d]);
          const toLatin = (s) =>
            (s ?? "").toString().replace(/[Ÿ†-Ÿ©]/g, (d) => EAST.indexOf(d));
          function normalizeData(qs, style) {
            const conv = style === "eastern" ? toEastern : toLatin;
            qs.forEach((q) => {
              if (q.reading?.text) q.reading.text = conv(q.reading.text);
              if (typeof q.readingText === "string")
                q.readingText = conv(q.readingText);
              else if (
                q.readingText &&
                typeof q.readingText === "object" &&
                q.readingText.text
              )
                q.readingText.text = conv(q.readingText.text);
              if (q.paragraph) q.paragraph = conv(q.paragraph);
              if (q.question?.text) q.question.text = conv(q.question.text);
              (q.options || []).forEach((o) => {
                if (o?.text) o.text = conv(o.text);
              });
            });
          }
          normalizeData(cleanQuestions, numeral);

          // DOMPurify ÿ•ŸÜ ŸÑŸÖ ÿ™ŸÉŸÜ ŸÖŸàÿ¨ŸàÿØÿ©
          const head = teacherHTML.querySelector("head");
          const needScript = (needle) =>
            ![...teacherHTML.querySelectorAll("script[src]")].some((s) =>
              s.src.includes(needle)
            );
          if (needScript("purify")) {
            const dp = doc.createElement("script");
            dp.src =
              "https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js";
            dp.defer = true;
            head.appendChild(dp);
          }

          // CSS ŸÑÿ™ÿÆÿ∑Ÿäÿ∑ 4√ó1 ÿπŸÑŸâ ÿßŸÑÿ¥ÿßÿ¥ÿßÿ™ ÿßŸÑÿπÿ±Ÿäÿ∂ÿ©
          if (!teacherHTML.querySelector("style[data-student-4x1]")) {
            const styleTag = doc.createElement("style");
            styleTag.setAttribute("data-student-4x1", "");
            styleTag.textContent =
              '@media (min-width: 769px){ .options[data-layout="4x1"]{ grid-template-columns: repeat(4, minmax(0,1fr)); } }';
            head.appendChild(styleTag);
          }

          // ÿ≥ŸÉÿ±ÿ®ÿ™ ÿßŸÑÿ∑ÿßŸÑÿ®
          const studentScript = doc.createElement("script");
          studentScript.defer = true;
          studentScript.textContent = `
        (function(){
          var studentState = {
            questions: ${JSON.stringify(cleanQuestions)},
            currentQuestion: 0,
            score: 0,
            timeLeft: ${qTime},
            questionTime: ${qTime},
            timerId: null,
            isPaused: false,
            answeredQuestions: [],
            lastWrong: [],
            numeralType: ${JSON.stringify(numeral)},
            shuffledMaps: [],
            optionsLayout: ${JSON.stringify(layoutChoice)} // "2x2" ÿ£Ÿà "4x1"
          };

          var EASTERN = ['Ÿ†','Ÿ°','Ÿ¢','Ÿ£','Ÿ§','Ÿ•','Ÿ¶','Ÿß','Ÿ®','Ÿ©'];
          var fmtAr = new Intl.NumberFormat('ar-EG');
          var fmtLa = new Intl.NumberFormat('en-US');
          function formatNumber(n){ return studentState.numeralType==='eastern' ? fmtAr.format(n) : fmtLa.format(n); }
          function convertNumeralsInText(text){
            if(!text || typeof text!=='string') return text;
            return studentState.numeralType==='eastern' ? text.replace(/\\d/g, function(d){return EASTERN[d];})
                                                         : text.replace(/[Ÿ†-Ÿ©]/g, function(d){return EASTERN.indexOf(d);});
          }
          function sanitizeHTML(html){
            if (!window.DOMPurify) return html || '';
            return DOMPurify.sanitize(html || '', {
              ADD_TAGS: ['a','u','mark','blockquote','hr','pre','code','h1','h2','h3','h4','h5','h6','ul','ol','li','img','table','thead','tbody','tr','td','th','p','span','div','br','sub','sup','strong','em'],
              ALLOWED_ATTR: ['src','alt','style','class','rowspan','colspan','href','target','rel','dir','width','height'],
              ALLOW_DATA_ATTR: false,
              FORBID_ATTR: ['onerror','onclick']
            });
          }
          function plainToHTMLStrict(src){
            if (!src || typeof src!=='string') return '';
            var ESC = function(s){ return s.replace(/[&<>]/g, function(m){return ({'&':'&amp;','<':'&lt;','>':'&gt;'}[m]);}); };
            var lines = src.split(/\\r?\\n/), out = [];
            for (var k=0;k<lines.length;k++){
              var raw = lines[k], s = raw.trim();
              if (!s){ out.push('<p>&nbsp;</p>'); continue; }
              if (/^\\/\\/\\/+$/ .test(s)) { out.push('<hr>'); continue; }
              s = ESC(s).replace(/(?:\\s*\\/\\/\\s*)+/g, '<br>');
              var m2 = s.match(/^(\\*+|[\\-\\u2212\\u2013\\u2014]|[\\(\\[]?[0-9Ÿ†-Ÿ©]+[\\)\\.\\-:]|[IVXLC]+[\\)\\.\\:])\\s+(.*)$/i);
              if (m2){ s = '<span class="lead-in">'+m2[1]+'</span> '+m2[2]; }
              out.push('<p>'+s+'</p>');
            }
            if (!out.length) out.push('<p>&nbsp;</p>');
            return out.join('');
          }
          function formatQuizContent(html){
            if (!html || typeof html!=='string') return '';
            var looksHTML = /<\\/?[a-z][\\s\\S]*>/i.test(html);
            var rendered = looksHTML ? html : plainToHTMLStrict(html);
            var tempDiv = document.createElement('div'); tempDiv.innerHTML = rendered;
            (function walk(node){
              if (node.nodeType === Node.TEXT_NODE){
                node.nodeValue = convertNumeralsInText(node.nodeValue);
              } else if (node.nodeType === Node.ELEMENT_NODE){
                for (var i=0;i<node.childNodes.length;i++) walk(node.childNodes[i]);
              }
            })(tempDiv);
            return sanitizeHTML(tempDiv.innerHTML);
          }
          function shuffleOptionsOnce(qIndex){
            if(studentState.shuffledMaps[qIndex]) return studentState.shuffledMaps[qIndex];
            var q=studentState.questions[qIndex]; var map=(q.options||[]).map(function(_,i){return i;});
            for(var i=map.length-1;i>0;i--){ var j=Math.floor(Math.random()*(i+1)); var t=map[i]; map[i]=map[j]; map[j]=t; }
            studentState.shuffledMaps[qIndex]=map; return map;
          }
          function startTimer(){
            clearInterval(studentState.timerId);
            var endAt=Date.now()+studentState.questionTime*1000;
            studentState.timerId=setInterval(function(){
              if(studentState.isPaused) return;
              var remain=Math.max(0, Math.ceil((endAt-Date.now())/1000));
              studentState.timeLeft=remain; updateTimerDisplay();
              if(remain<=0){ clearInterval(studentState.timerId); nextQuestion(); }
            },200);
          }
          function updateTimerDisplay(){ var el=document.getElementById('timer'); if(el) el.textContent = 'ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä: '+formatNumber(studentState.timeLeft)+' ÿ´ÿßŸÜŸäÿ©'; }
          function updateQuestionCounter(){ var el=document.getElementById('questionCounter'); if(el) el.textContent = 'ÿßŸÑÿ≥ÿ§ÿßŸÑ '+formatNumber(studentState.currentQuestion+1)+' ŸÖŸÜ '+formatNumber(studentState.questions.length); }
          function updateScoreCounter(){ var el=document.getElementById('scoreCounter'); if(el) el.textContent = 'ÿßŸÑÿØÿ±ÿ¨ÿßÿ™: ' + formatNumber(studentState.score) + ' ŸÖŸÜ ' + formatNumber(studentState.questions.length); }

          // ÿ™ÿÆÿ∑Ÿäÿ∑ 4√ó1 ÿßŸÑÿ¢ŸÖŸÜ
          function canApplyChosenLayout(layout, optionCount){
            if (layout === '4x1') {
              return optionCount === 4 && window.matchMedia('(min-width: 769px)').matches;
            }
            return false; // ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä 2√ó2
          }
          function applyLayoutSafely(optionCount){
            var el = document.getElementById('options');
            if (!el) return;
            if (canApplyChosenLayout(studentState.optionsLayout, optionCount)){
              el.dataset.layout = '4x1';
            } else {
              delete el.dataset.layout; // ÿ±ÿ¨Ÿàÿπ ŸÅŸàÿ±Ÿä ŸÑŸÑÿ£ÿµŸÑ
            }
          }

          function showQuestion(){
            clearInterval(studentState.timerId); studentState.timeLeft=studentState.questionTime;
            var readingText=document.getElementById('readingText'); var questionEl=document.getElementById('question'); var optionsEl=document.getElementById('options');
            if(studentState.currentQuestion>=studentState.questions.length){ showResult(); return; }
            var q=studentState.questions[studentState.currentQuestion];

            if (readingText){ readingText.innerHTML=''; }
            var readingTextContent='', readingImageSrc=null;
            if (q.reading){ readingTextContent = q.reading.text || ''; readingImageSrc = q.reading.image || null; }
            else if (q.readingText){ readingTextContent = typeof q.readingText==='string' ? q.readingText : (q.readingText.text||''); readingImageSrc = typeof q.readingText==='object' ? (q.readingText.image||null) : null; }
            else if (q.paragraph){ readingTextContent = q.paragraph; readingImageSrc = q.paragraphImage || null; }
            if (readingText){
              if(readingTextContent || readingImageSrc){
                readingText.style.display='block';
                if(readingTextContent){ var d=document.createElement('div'); d.className='reading-text-content'; d.innerHTML=formatQuizContent(readingTextContent); readingText.appendChild(d); }
                if(readingImageSrc){ var im=document.createElement('img'); im.src=readingImageSrc; im.className='reading-text-image'; im.alt='Reading image'; im.loading='lazy'; im.decoding='async'; readingText.appendChild(im); }
              } else readingText.style.display='none';
            }

            if (questionEl){
              questionEl.innerHTML='';
              var qc=document.createElement('div'); qc.className='question-content';
              if(q.question && q.question.text){ var d2=document.createElement('div'); d2.className='question-text'; d2.innerHTML = formatQuizContent(q.question.text); qc.appendChild(d2); }
              if(q.question && q.question.image){ var i2=document.createElement('img'); i2.src=q.question.image; i2.className='question-image'; i2.alt='Question image'; i2.loading='lazy'; i2.decoding='async'; qc.appendChild(i2); }
              questionEl.appendChild(qc);
            }

            if (!optionsEl) return;
            optionsEl.innerHTML=''; if(!q.options || q.options.length===0) return;
            optionsEl.setAttribute('role','radiogroup');

            var map=shuffleOptionsOnce(studentState.currentQuestion); var list=[];
            map.forEach(function(origIdx){
              var opt=q.options[origIdx]; if(!opt||(!opt.text&&!opt.image)) return;
              var wrap=document.createElement('div'); wrap.className='option'; wrap.setAttribute('role','radio'); wrap.setAttribute('tabindex','0'); wrap.setAttribute('aria-checked','false');
              var c=document.createElement('div'); c.className='option-content';
              if(opt.image){ var im2=document.createElement('img'); im2.src=opt.image; im2.className='option-image'; im2.alt='Option image'; im2.loading='lazy'; im2.decoding='async'; c.appendChild(im2); }
              if(opt.text){ var s=document.createElement('span'); s.className='option-text'; s.innerHTML=formatQuizContent(opt.text); c.appendChild(s); }
              wrap.appendChild(c);
              if(studentState.answeredQuestions[studentState.currentQuestion]!==null){
                wrap.setAttribute('aria-disabled','true');
                if(origIdx===q.correct) wrap.classList.add('correct');
                if(studentState.answeredQuestions[studentState.currentQuestion]===false && studentState.lastWrong[studentState.currentQuestion]===origIdx) wrap.classList.add('wrong');
                var selectedIdx = studentState.answeredQuestions[studentState.currentQuestion] === true ? q.correct : studentState.lastWrong[studentState.currentQuestion];
                wrap.setAttribute('aria-checked', String(origIdx === selectedIdx));
              }
              wrap.onclick=function(){ checkAnswer(origIdx); };
              wrap.onkeydown=function(e){
                if(e.key==='Enter'||e.key===' '){ e.preventDefault(); checkAnswer(origIdx); return; }
                if(e.key==='ArrowRight'||e.key==='ArrowDown'||e.key==='ArrowLeft'||e.key==='ArrowUp'){
                  var items = Array.from(document.querySelectorAll('#options .option'));
                  var idx = items.indexOf(wrap); var next = idx;
                  if (e.key==='ArrowRight'||e.key==='ArrowDown') next++; else next--;
                  if (next<0) next = items.length-1; if (next>=items.length) next=0;
                  var el2 = items[next]; if(el2) el2.focus();
                }
              };
              list.push(wrap);
            });

            // ÿ∑ÿ®ŸëŸÇ ÿßŸÑÿ™ÿÆÿ∑Ÿäÿ∑ ÿ®ÿπÿØ ÿßŸÉÿ™ŸÖÿßŸÑ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©
            applyLayoutSafely(list.length);

            optionsEl.classList.remove('options-row','options-two','options-three');
            if(list.length<=3){
              optionsEl.classList.add('options-row');
              if(list.length===2) optionsEl.classList.add('options-two');
              else if(list.length===3) optionsEl.classList.add('options-three');
            }
            list.forEach(function(v){ optionsEl.appendChild(v); });

            var prevBtn=document.getElementById('prevBtn'); var nextBtn=document.getElementById('nextBtn');
            if (prevBtn) prevBtn.disabled = studentState.currentQuestion===0;
            if (nextBtn) nextBtn.disabled = false;

            var prog=document.getElementById('progress');
            if (prog) {
              var total = Array.isArray(studentState.questions) ? studentState.questions.length : 0;
              var pct   = total>0 ? (studentState.currentQuestion/total)*100 : 0;
              prog.style.width = pct + '%';
            }

            updateQuestionCounter(); updateScoreCounter(); updateTimerDisplay(); startTimer();
          }

          function checkAnswer(selectedIndex){
            if(studentState.answeredQuestions[studentState.currentQuestion]!==null) return;
            var q=studentState.questions[studentState.currentQuestion];
            document.querySelectorAll('.option').forEach(function(o){o.setAttribute('aria-disabled','true');});
            var correct=q.correct;
            if(selectedIndex===correct){ studentState.score++; studentState.answeredQuestions[studentState.currentQuestion]=true; }
            else { studentState.answeredQuestions[studentState.currentQuestion]=false; studentState.lastWrong[studentState.currentQuestion]=selectedIndex; }
            var map=studentState.shuffledMaps[studentState.currentQuestion]||[];
            document.querySelectorAll('.option').forEach(function(el,i){
              var orig=map[i];
              if(orig===correct) el.classList.add('correct');
              if(studentState.answeredQuestions[studentState.currentQuestion]===false && orig===studentState.lastWrong[studentState.currentQuestion]) el.classList.add('wrong');
              el.setAttribute('aria-checked', String(orig===selectedIndex));
            });
            updateScoreCounter();
            if(studentState.currentQuestion < studentState.questions.length-1) setTimeout(nextQuestion, 1000); else setTimeout(showResult, 1000);
          }

          function nextQuestion(){ if(studentState.currentQuestion>=studentState.questions.length-1){ showResult(); return; } studentState.currentQuestion++; showQuestion(); }
          function previousQuestion(){ if(studentState.currentQuestion>0){ studentState.currentQuestion--; showQuestion(); } }

          function showResult(){
            clearInterval(studentState.timerId);
            var qb=document.querySelector('.quiz-box'); if (qb) qb.style.display='none';
            var sb=document.getElementById('scoreBoard'); if (sb) sb.style.display='block';
            var rt=document.getElementById('readingText'); if (rt) rt.style.display='none';
            var ct=document.getElementById('countersBox'); if (ct) ct.style.display='none';
            var fs=document.getElementById('finalScore'); if (fs) fs.textContent = formatNumber(studentState.score);
            var tq=document.getElementById('totalQuestions'); if (tq) tq.textContent = formatNumber(studentState.questions.length);
          }

          function restartQuiz(){
            studentState.currentQuestion=0; studentState.score=0; studentState.timeLeft=studentState.questionTime;
            studentState.answeredQuestions=new Array(studentState.questions.length).fill(null);
            studentState.lastWrong=new Array(studentState.questions.length).fill(null);
            var qb=document.querySelector('.quiz-box'); if (qb) qb.style.display='block';
            var sb=document.getElementById('scoreBoard'); if (sb) sb.style.display='none';
            var ct=document.getElementById('countersBox'); if (ct) ct.style.display='flex';
            var p=document.getElementById('progress'); if(p) p.style.width='0%';
            document.querySelectorAll('.option').forEach(function(o){ o.classList.remove('correct','wrong'); o.removeAttribute('aria-disabled'); });
            showQuestion();
          }

          function togglePause(){ studentState.isPaused=!studentState.isPaused; var b=document.getElementById('pauseBtn'); if (b){ b.textContent = studentState.isPaused ? 'Resume' : ' Pause'; b.style.background = studentState.isPaused ? '#28a745' : '#ffc107'; } }

          // ÿ¥ÿ®ŸÉÿ© ÿ£ŸÖÿßŸÜ
          window.nextQuestion     = nextQuestion;
          window.previousQuestion = previousQuestion;
          window.togglePause      = togglePause;
          window.restartQuiz      = restartQuiz;

          // ÿ•ÿπÿßÿØÿ© ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ™ÿÆÿ∑Ÿäÿ∑ ÿπŸÜÿØ ÿ™ÿ∫ŸäŸäÿ± ÿ≠ÿ¨ŸÖ ÿßŸÑÿ¥ÿßÿ¥ÿ©
          window.addEventListener('resize', function(){
            var count = document.querySelectorAll('#options .option').length;
            applyLayoutSafely(count);
          });

          window.addEventListener('load', function(){
            var prevBtn=document.getElementById('prevBtn'); if(prevBtn) prevBtn.onclick = previousQuestion;
            var nextBtn=document.getElementById('nextBtn'); if(nextBtn) nextBtn.onclick = nextQuestion;
            var pauseBtn=document.getElementById('pauseBtn'); if(pauseBtn) pauseBtn.onclick = togglePause;
            var restart=document.querySelector('.restart-btn'); if(restart) restart.onclick = restartQuiz;

            studentState.answeredQuestions=new Array(studentState.questions.length).fill(null);
            studentState.lastWrong=new Array(studentState.questions.length).fill(null);
            showQuestion();
          });
        })();
      `;
          head.appendChild(studentScript);

          // ŸÜÿ∏ŸëŸÅ ÿßŸÑÿ≥ŸÉÿ±ÿ®ÿ™ÿßÿ™: ÿ£ÿ®ŸÇŸê Purify ŸàÿßŸÑÿ∑ÿßŸÑÿ® ŸÅŸÇÿ∑
          [...teacherHTML.querySelectorAll("script")].forEach((s) => {
            const src = s.getAttribute("src") || "";
            const isPurify = src.includes("purify");
            const isStudent = s === studentScript;
            if (!(isPurify || isStudent)) s.remove();
          });

          // ÿ£ŸÜÿ¥ÿ¶ ÿßŸÑŸÖŸÑŸÅ
          const out = "<!DOCTYPE html>\n" + teacherHTML.outerHTML;
          const blob = new Blob([out], { type: "text/html" });
          const url = URL.createObjectURL(blob);
          const suffix = numeral;
          const a = document.createElement("a");
          a.href = url;
          a.download = "quiz_student_lite_" + suffix + ".html";
          a.click();
          setTimeout(() => URL.revokeObjectURL(url), 200);
        } catch (err) {
          console.error("ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ŸÜÿ≥ÿÆÿ© ÿßŸÑÿ∑ÿßŸÑÿ® (Lite):", err);
          alert("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ŸÜÿ≥ÿÆÿ© ÿßŸÑÿ∑ÿßŸÑÿ® (Lite).");
        }
      }

      function resetProgress() {
        if (!confirm("Reset progress?")) return;
        localStorage.removeItem(STORAGE_KEY);
        state.currentQuestion = 0;
        state.score = 0;
        state.timeLeft = state.questionTime;
        state.answeredQuestions = new Array(state.questions.length).fill(null);
        state.lastWrong = new Array(state.questions.length).fill(null);
        state.shuffledMaps = [];
        showQuestion();
      }

      window.nextQuestion = nextQuestion;
      window.previousQuestion = previousQuestion;
      window.togglePause = togglePause;
      window.restartQuiz = restartQuiz;

      window.addEventListener("load", () => {
        const rt = document.getElementById("readingText");
        if (rt) rt.style.display = "none";
        document.getElementById("loadButton").onclick = loadQuestionsFromFile;
        document.getElementById("saveQuestionsButton").onclick =
          saveQuestionsToFile;
        document.getElementById("saveAppButton").onclick = saveAppForOfflineUse;
        // Keyboard shortcuts for quick selection: 1..9
        document.addEventListener("keydown", (e) => {
          const tag = (e.target && e.target.tagName) || "";
          if (tag === "INPUT" || tag === "TEXTAREA") return;
          if (!/^\d$/.test(e.key)) return;
          const idx = Number(e.key) - 1;
          const map = state.shuffledMaps[state.currentQuestion] || [];
          if (
            idx >= 0 &&
            idx < map.length &&
            state.answeredQuestions[state.currentQuestion] === null
          ) {
            e.preventDefault();
            const origIdx = map[idx];
            if (origIdx !== undefined) checkAnswer(origIdx);
          }
        });
        document.getElementById("questionCounter").textContent =
          "Question " + formatNumber(0) + " of " + formatNumber(0);
        document.getElementById("timer").textContent =
          "Time left: " + formatNumber(state.timeLeft) + " seconds";
        document.getElementById("scoreCounter").textContent =
          "Score: " + formatNumber(0) + " of " + formatNumber(0);
        init();
        const layoutSel = document.getElementById("optionsLayout");
        if (layoutSel) layoutSel.value = state.optionsLayout;
      });

      document.addEventListener("paste", (e) => {
        const item = [...(e.clipboardData?.items || [])].find(
          (i) => i.type && i.type.startsWith("image/")
        );
        if (!item) return;
        const file = item.getAsFile();
        const r = new FileReader();
        r.onload = () => {
          const url = r.result;
          const q = state.questions[state.currentQuestion] || {};
          if (!q.question) q.question = { text: "", image: null };
          q.question.image = url;
          showQuestion();
          persist();
        };
        r.readAsDataURL(file);
      });
    </script>
  </body>
</html>
